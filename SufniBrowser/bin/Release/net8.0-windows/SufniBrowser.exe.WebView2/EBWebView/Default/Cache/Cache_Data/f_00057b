/* Bundle Includes:
 *   js/fm/albums/AlbumTimeline.js
 *   js/ui/notificationBanner.js
 *   js/ui/components/header.js
 *   js/ui/components/top-menu.js
 *   js/ui/components/storage-block.js
 */

lazy(mega.gallery, 'AlbumTimeline', () => {
    'use strict';

    const scope = mega.gallery;
    const { albums } = scope;
    const defZoomStep = 2;

    /**
     * Getting the month label for the node
     * @param {MegaNode} node Node to fetch the label from
     * @returns {String}
     */
    const getMonthLabel = ({ mtime, ts }) => GalleryNodeBlock.getTimeString(mtime || ts, 3);

    let globalZoomStep = defZoomStep;

    const fillAlbumTimelineCell = (el) => {
        if (el.ref.isVideo && !el.dataset.videoDuration) {
            el.dataset.videoDuration = secondsToTimeShort(MediaAttribute(el.ref.node).data.playtime);
            el.classList.add('show-video-duration');

            const icon = document.createElement('i');
            icon.className = 'video-thumb-play sprite-fm-mono icon-play-circle';
            el.appendChild(icon);
        }
    };

    class AlbumItemContextMenu extends MMenuSelect {
        constructor() {
            super();

            const selections = Object.keys(albums.grid.timeline.selections);
            const albumId = scope.getAlbumIdFromPath();
            const album = albums.store[albumId];
            const { filterFn, at, eIds, nodes, id } = album;
            const { featureEnabled } = mega.sensitives;
            const options = [];
            let selectionsPreviewable = false;
            let toApplySensitive = 2; // 0 - Disable, 1 - Hide, 2 - Unhide

            const isCoverChangeable = !filterFn
                && selections.length === 1
                && (!at.c || eIds[at.c] !== selections[0]);
            const onlyPlayableVideosSelected = selections.every((h) => !!is_video(M.d[h]));

            if (!mega.sensitives.isViewEnabled()
                || selections.some((h) => !mega.sensitives.nodeCanBeSensitive(h))) {
                toApplySensitive = 0;
            }
            else if (featureEnabled) {
                let checksLeft = 2;

                for (let i = 0; i < selections.length; i++) {
                    if (!selectionsPreviewable && scope.isPreviewable(M.d[selections[i]])) {
                        selectionsPreviewable = true;
                        checksLeft--;
                    }

                    if (toApplySensitive !== 1 && !mega.sensitives.isSensitive(selections[i], false)) {
                        toApplySensitive = 1;
                    }

                    // The rest of selections can be skipped, as all checks are passed
                    if (checksLeft <= 0) {
                        break;
                    }
                }
            }
            else {
                toApplySensitive = 1;
            }

            if (onlyPlayableVideosSelected) {
                options.push({
                    label: l.album_play_video,
                    icon: 'video-call-filled',
                    click: () => {
                        scope.playSlideshow(albumId, false, true);
                    }
                });
            }
            else if (scope.nodesAllowSlideshow(nodes)) {
                options.push({
                    label: l.album_play_slideshow,
                    icon: 'play-square',
                    click: () => {
                        scope.playSlideshow(albumId, true);
                    }
                });
            }

            if (selectionsPreviewable) {
                options.push(
                    {
                        label: l.album_item_preview_label,
                        icon: 'preview-reveal',
                        click: () => {
                            scope.playSlideshow(albumId);
                        }
                    }
                );
            }

            if (options.length) {
                options.push({});
            }

            if (id === 'fav' && selections.every(h => M.d[h].fav)) {
                options.push({
                    label: l[5872],
                    icon: 'favourite-removed',
                    click: () => {
                        M.favourite(selections, 0);
                    }
                });
            }

            options.push(
                {
                    label: l.album_download,
                    icon: 'download-small',
                    click: () => {
                        if (M.currentdirid !== `albums/${albumId}`) {
                            return;
                        }

                        const handles = scope.getAlbumsHandles([albumId]);

                        if (!handles.length) {
                            return;
                        }

                        scope.reportDownload();
                        M.addDownload(handles);
                    }
                }
            );

            if (isCoverChangeable) {
                options.push({
                    label: l.set_as_album_cover,
                    icon: 'images',
                    click: () => {
                        if (M.isInvalidUserStatus()) {
                            return;
                        }

                        if (albums.grid.timeline.selCount === 1) {
                            albums.updateAlbumCover(album, Object.keys(albums.grid.timeline.selections)[0]);
                        }
                    }
                });
            }

            if (toApplySensitive) {
                if (toApplySensitive === 1) {
                    options.push({
                        label: l.sen_hide,
                        icon: 'eye-hidden',
                        click: () => {
                            if (M.isInvalidUserStatus()) {
                                return;
                            }

                            mega.sensitives.toggleStatus(selections, true);
                        },
                        oncreate: (item) => {
                            mega.sensitives.applyProBadge($(item.el));
                        }
                    });
                }
                else {
                    options.push({
                        label: l.sen_unhide,
                        icon: 'eye-reveal',
                        click: () => {
                            mega.sensitives.toggleStatus(selections, false);
                        },
                        oncreate: (item) => {
                            mega.sensitives.applyProBadge($(item.el));
                        }
                    });
                }
            }

            if (!filterFn) {
                options.push(
                    {},
                    {
                        label: l.album_item_remove_label,
                        icon: 'bin',
                        click: () => {
                            if (M.isInvalidUserStatus()) {
                                return;
                            }

                            albums.requestAlbumElementsRemoval();
                        },
                        classes: ['red']
                    }
                );
            }

            this.options = options;
        }
    }

    class PublicAlbumItemContextMenu extends MMenuSelect {
        constructor() {
            super();

            const selections = Object.keys(albums.grid.timeline.selections);

            const albumId = scope.getAlbumIdFromPath();
            const { nodes } = albums.store[albumId];
            const options = [];

            const hasImageSelected = selections.some(h => !!scope.isImage(M.d[h]));
            const onlyPlayableVideosSelected = selections.every((h) => !!is_video(M.d[h]));

            if (hasImageSelected) {
                options.push({
                    label: l.album_item_preview_label,
                    icon: 'preview-reveal',
                    click: () => {
                        scope.playSlideshow(albumId);
                    }
                });

                if (scope.nodesAllowSlideshow(nodes)) {
                    options.push({
                        label: l.album_play_slideshow,
                        icon: 'play-square',
                        click: () => {
                            scope.playSlideshow(albumId, true);
                        }
                    });
                }
            }

            if (onlyPlayableVideosSelected) {
                options.push({
                    label: l.album_play_video,
                    icon: 'video-call-filled',
                    click: () => {
                        scope.playSlideshow(albumId, false, true);
                    }
                });
            }

            options.push(
                {},
                {
                    label: l.album_download,
                    icon: 'download-small',
                    click: () => {
                        if (M.isInvalidUserStatus()) {
                            return;
                        }

                        if (!M.isAlbumsPage()) {
                            return;
                        }

                        eventlog(99954);
                        M.addDownload(selections);
                    }
                },
                {},
                {
                    label: l[6859],
                    icon: 'info',
                    click: () => {
                        $.selected = selections;
                        mega.ui.mInfoPanel.initInfoPanel();
                    }
                },
                {},
                {
                    label: (u_type) ? l.context_menu_import : l.btn_imptomega,
                    icon: (u_type) ? 'upload-to-cloud-drive' : 'mega-thin-outline',
                    click: () => {
                        if (M.isInvalidUserStatus()) {
                            return;
                        }

                        assert(albums.isPublic, 'This import needs to happen in public album only...');

                        eventlog(99832);
                        M.importFolderLinkNodes(selections);
                    }
                }
            );

            this.options = options;
        }
    }

    class AlbumTimelineCell extends MComponent {
        /**
         * @param {Object.<String, any>} data Data for the cell
         * @param {MegaNode} data.node Node to base on
         * @param {Function} data.clickFn Single click handler
         * @param {Function} data.dbclickFn Double click handler
         * @param {Boolean} data.useMenu Whether to use context menu or skip it
         */
        constructor({ node, clickFn, dbclickFn, useMenu }) {
            super();

            this.el.ref = {
                node,
                isVideo: !!scope.isVideo(node),
                setThumb: (dataUrl) => {
                    this.setThumb(dataUrl);
                }
            };

            this.el.setAttribute('title', node.name);
            this.el.setAttribute('id', node.h);

            this._active = true;
            this._selected = false;
            this.isSensitive = !!mega.sensitives.isSensitive(node);

            this.attachEvents(clickFn, dbclickFn, useMenu);
        }

        get isActive() {
            return this._active;
        }

        /**
         * Using this parameter to grey-out the cell when needed
         * @param {Boolean} status Active status
         * @returns {void}
         */
        set isActive(status) {
            if (status) {
                this.el.classList.remove('opacity-50');
            }
            else {
                this.el.classList.add('opacity-50');
            }
        }

        get isSelected() {
            return this._selected;
        }

        /**
         * @param {Boolean} status Selected status
         * @returns {void}
         */
        set isSelected(status) {
            if (status === this._selected) {
                return;
            }

            if (status) {
                this.el.classList.add('ui-selected');

                const check = document.createElement('i');
                check.className = 'sprite-fm-mono icon-check';
                this.el.appendChild(check);
                this._selected = true;

                if (!this._active) {
                    this.isActive = true;
                }
            }
            else {
                this.el.classList.remove('ui-selected');
                this.el.removeChild(this.el.querySelector('i.icon-check'));
                this._selected = false;
            }
        }

        get isSensitive() {
            return this._sensitive;
        }

        /**
         * @param {Boolean} status Sensitive status
         * @returns {void}
         */
        set isSensitive(status) {
            if (status === this._sensitive) {
                return;
            }

            this._sensitive = status;

            if (status) {
                this.el.classList.add('is-sensitive');
            }
            else {
                this.el.classList.remove('is-sensitive');
            }
        }

        buildElement() {
            this.el = document.createElement('div');
            this.el.className = 'album-timeline-cell cursor-pointer';
        }

        attachEvents(clickFn, dbclickFn, useMenu) {
            if (clickFn) {
                this.attachEvent('mouseup', (evt) => {
                    if (evt.which === 3) {
                        return false;
                    }

                    if (!evt.detail || evt.detail === 1) {
                        clickFn(this, evt);
                    }
                    else if (evt.detail === 2) {
                        dbclickFn(this, evt);
                    }
                });
            }

            if (useMenu) {
                this.attachEvent(
                    'contextmenu',
                    (evt) => {
                        evt.preventDefault();
                        const { pageX, pageY, target } = evt;

                        if (!this.isSelected) {
                            clickFn(this, evt);
                        }

                        if (albums.isPublic) {
                            const contextMenu = new PublicAlbumItemContextMenu(target);
                            contextMenu.show(pageX, pageY);
                        }
                        else {
                            const contextMenu = new AlbumItemContextMenu(target);
                            contextMenu.show(pageX, pageY);
                        }
                    }
                );
            }
        }

        setThumb(dataUrl) {
            let img = this.el.querySelector('img');

            if (!img) {
                img = document.createElement('img');
                img.className = 'w-full h-full absolute';
                this.el.appendChild(img);
            }

            img.src = dataUrl;

            this.naturalSize = this.el.style.width;

            if (this.el.classList.contains('shimmer')) {
                scope.unsetShimmering(this.el);
            }
        }
    }

    class AlbumTimeline extends MComponent {
        /**
         * The sorted list of nodes (newest at top) with the specific handler
         * @param {Object.<String, any>} options Options object
         * @param {Function} options.onSelectToggle Method is called when the cell status is changed
         * @param {Function} options.onDoubleClick Method is called when the cell is double clicked
         * @param {String} [options.containerClass] Additional classes for container
         * @param {Number} [options.sidePadding] Use this correction, if container classes include x-axis padding
         * @param {Boolean} [options.showMonthLabel] Whether to show month timestamps or not
         * @param {Boolean} [options.interactiveCells] Whether cells should react to context menu and selections
         * @param {Boolean} [options.selectionLimit] Whether a multiple selection is allowed or not
         * @param {Boolean} [options.skipGlobalZoom] Whether to use global zoom or the locally created one
         */
        constructor({
            onSelectToggle,
            onDoubleClick,
            containerClass,
            sidePadding,
            showMonthLabel,
            interactiveCells,
            selectionLimit,
            skipGlobalZoom
        }) {
            super(null, false);

            this.sidePadding = sidePadding || 0;

            if (typeof containerClass === 'string') {
                this.el.className = containerClass;
            }

            this.dynamicList = false;

            this.rowIndexCache = {};
            this.cellCache = {};

            this.selections = {};
            this.selectArea = null;
            this.shiftSelectedIndexes = [];

            this.onSelectToggle = onSelectToggle;
            this.onDoubleClick = onDoubleClick;
            this.showMonthLabel = showMonthLabel;
            this.interactiveCells = interactiveCells;
            this.skipGlobalZoom = skipGlobalZoom;
            this.selectionLimit = selectionLimit || 0;

            this._zoomStep = skipGlobalZoom ? defZoomStep : globalZoomStep;
            this._limitReached = false;
            this._selCount = 0;

            this.el.classList.add(`album-timeline-zoom-${this._zoomStep}`);
            this.attachEvents();
        }

        get selCount() {
            return this._selCount;
        }

        get zoomStep() {
            return this._zoomStep;
        }

        get limitReached() {
            return this._limitReached;
        }

        /**
         * @param {Boolean} status Whether the limit is reached or not
         */
        set limitReached(status) {
            this._limitReached = status;

            delay('album_timeline:toggle_cell_activation', () => {
                const selector = '.album-timeline-cell'
                    + (this._limitReached ? ':not(.opacity-50)' : '.opacity-50')
                    + ':not(.ui-selected)';


                const cellsToToggle = this.el.querySelectorAll(selector);

                if (cellsToToggle.length) {
                    for (let i = 0; i < cellsToToggle.length; i++) {
                        cellsToToggle[i].mComponent.isActive = !this._limitReached;
                    }
                }
            }, 100);
        }

        /**
         * @param {Number} step The zoom step index
         * @returns {void}
         */
        set zoomStep(step) {
            step = parseInt(step);

            if (isNaN(step)) {
                step = 0;
            }

            if (step >= AlbumTimeline.zoomSteps.length || step < 0) {
                return;
            }

            this.el.classList.remove(`album-timeline-zoom-${this._zoomStep}`);
            this._zoomStep = step;
            this.el.classList.add(`album-timeline-zoom-${step}`);

            if (!this.skipGlobalZoom) {
                globalZoomStep = step;
            }

            if (this.dynamicList && this._nodes.length) {
                this.nodes = this._nodes.map(({ list }) => list).flat();
            }
        }

        /**
         * @param {MegaNode[]} nodes The new list of nodes to use
         * @returns {void}
         */
        set nodes(nodes) {
            let $middleBlock;

            if (this.dynamicList) {
                $middleBlock = this.findMiddleImage();
                this.dynamicList.destroy();
                this.dynamicList = null;
            }

            MComponent.resetSubElements(this, '_nodes', false);

            if (!nodes.length) {
                return;
            }

            this._winWidth = window.innerWidth;
            this._winHeight = window.innerHeight;
            this.setCellSize();

            this.dynamicList = new MegaDynamicList(this.el, {
                itemRenderFunction: this.renderRow.bind(this),
                itemHeightCallback: this.getRowHeight.bind(this),
                onResize: this.onResize.bind(this),
                perfectScrollOptions: {
                    handlers: ['click-rail', 'drag-thumb', 'wheel', 'touch'],
                    minScrollbarLength: 50
                }
            });

            const ids = [];
            let lastIndex = 0;
            let monthLabel = getMonthLabel(nodes[0]);
            this.rowIndexCache[nodes[0].h] = 0;
            this._nodes.push({
                list: [nodes[0]],
                monthLabel
            });

            for (let i = 1; i < nodes.length; i++) {
                const node = nodes[i];
                const lastEl = this._nodes[lastIndex];
                const curLabel = getMonthLabel(node);

                if (this.showMonthLabel && curLabel !== monthLabel) {
                    ids.push(lastIndex.toString());
                    monthLabel = curLabel;
                    lastIndex++;

                    this._nodes.push({
                        list: [node],
                        monthLabel
                    });
                }
                else if (lastEl.list.length % AlbumTimeline.zoomSteps[this.zoomStep] === 0) {
                    ids.push(lastIndex.toString());
                    lastIndex++;

                    this._nodes.push({
                        list: [node]
                    });
                }
                else {
                    lastEl.list.push(node);
                }

                this.rowIndexCache[node.h] = lastIndex;
            }

            if (!this.dynamicList.items[lastIndex]) {
                ids.push(lastIndex.toString());
            }

            this.dynamicList.batchAdd(ids);
            this.dynamicList.initialRender();

            if (this.zoomControls) {
                this.el.parentNode.prepend(this.zoomControls);
            }

            if ($middleBlock) {
                const listContainerHeight = this.el.offsetHeight;
                const blockSize = $('.album-timeline-cell', this.el).width();
                const rowIndex = this.rowIndexCache[$middleBlock.attr('id')];
                const newOffsetTop = this.dynamicList._offsets[rowIndex];
                this.dynamicList.scrollToYPosition(newOffsetTop - (listContainerHeight - blockSize) / 2);
            }

            delay('album_timeline:set_nodes', () => {
                if (this.dynamicList) {
                    this.dynamicList.options.onResize = this.onResize.bind(this);
                }
            });
        }

        getRowHeight(index) {
            const headerHeight = (this._nodes[index] && this._nodes[index].monthLabel)
                ? 44
                : 0;

            return this.cellSize + scope.cellMargin * 2 + headerHeight;
        }

        findMiddleImage() {
            const $blockViews = $('.album-timeline-cell', this.el);
            const contentOffset = $('.MegaDynamicList-content', this.el).offset();
            const listContainerHeight = this.el.offsetHeight;

            let middleBlock = null;
            let minDistance = 1e6;

            const { scrollTop } = this.el;

            for (const v of $blockViews) {
                const $v = $(v);

                if ($v.offset().left < contentOffset.left + 5) {
                    const blockSize = $v.width();
                    const blockTop = $v.offset().top - contentOffset.top - parseInt($v.css('margin-top'));
                    const middle = blockTop + blockSize / 2 - scrollTop;
                    const distance = Math.abs(listContainerHeight / 2 - middle);

                    if (distance < minDistance) {
                        minDistance = distance;
                        middleBlock = $v;
                    }
                }
            }

            return middleBlock;
        }

        clearSiblingSelections(ignoreHandle) {
            const handles = Object.keys(this.selections);

            for (let i = 0; i < handles.length; i++) {
                if (handles[i] !== ignoreHandle) {
                    this.deselectNode(M.d[handles[i]]);
                }
            }
        }

        attachEvents() {
            this.onNodeClick = (cell, evt) => {
                const { shiftKey } = evt;
                const { el, isSelected } = cell;

                if (this.selectionLimit === 1) {
                    this.selectNode(el.ref.node);
                    this.clearSiblingSelections(el.ref.node.h);
                    return;
                }

                this.lastNavNode = el.ref.node;

                if (shiftKey) {
                    if (this.selectStartNode && this.selectStartNode.h !== el.ref.node.h) {
                        this.selectElementsRange(this.selectStartNode, el.ref.node, true);
                    }
                    else {
                        this.clearSiblingSelections(el.ref.node.h);
                        this.selectStartNode = el.ref.node;
                    }
                }
                else {
                    if (isSelected) {
                        this.deselectNode(el.ref.node);
                        this.selectStartNode = null;
                        this.lastNavNode = null;
                    }
                    else {
                        this.selectNode(el.ref.node);
                        this.selectStartNode = el.ref.node;
                    }

                    this.shiftSelectedIndexes = [];
                }
            };

            this.onNodeDbClick = (cell, evt) => {
                this.selectStartNode = cell.el.ref.node;
                this.lastNavNode = null;

                if (this.onDoubleClick) {
                    this.onDoubleClick(cell, evt);
                }
            };

            this.attachKeyboardListener();

            if (this.selectionLimit !== 1) {
                this.attachDragListener();
            }
        }

        selectNonRenderedCells(posArr) {
            for (let i = 0; i < this._nodes.length; i++) {
                for (let j = 0; j < this._nodes[i].list.length; j++) {
                    const isInArea = scope.isInSelectArea(
                        {
                            offsetLeft: Math.floor(
                                this.cellSize * j + scope.cellMargin * (j * 2 + 1)
                            ),
                            offsetTop: Math.floor(
                                this.dynamicList._offsets[i.toString()] + scope.cellMargin
                            ),
                            offsetWidth: this.cellSize,
                            offsetHeight: this.cellSize
                        },
                        posArr,
                        this.sidePadding
                    );

                    if (isInArea) {
                        this.selectNode(this._nodes[i].list[j]);
                    }
                    else {
                        this.deselectNode(this._nodes[i].list[j]);
                    }
                }
            }
        }

        selectRenderedCells(posArr) {
            const keys = Object.keys(this.dynamicList._currentlyRendered);

            if (keys.length) {
                for (let i = 0; i < keys.length; i++) {
                    const children = this.dynamicList._currentlyRendered[keys[i]]
                        .querySelector(':scope > div .album-timeline-cell');

                    if (children && children.length) {
                        for (let j = 0; j < children.length; j++) {
                            if (scope.isInSelectArea(children[j], posArr, this.sidePadding)) {
                                this.selectNode(children[j].ref.node);
                                this.lastNavNode = children[j].ref.node;
                            }
                            else {
                                this.deselectNode(children[j].ref.node);
                            }
                        }
                    }
                }
            }
        }

        attachDragListener() {
            let initX = 0;
            let initY = 0;

            this.dragSelect = new mega.ui.dragSelect(
                this.el,
                {
                    allowedClasses: ['MegaDynamicListItem', 'flex-row'],
                    onDragStart: (xPos, yPos) => {
                        initX = xPos;
                        initY = this.dynamicList.getScrollTop() + yPos;
                        $.hideContextMenu();
                    },
                    onDragMove: (xPos, yPos) => {
                        const posArr = [];

                        yPos += this.dynamicList.getScrollTop();

                        if (xPos > initX) {
                            posArr.push(initX, xPos);
                        }
                        else {
                            posArr.push(xPos, initX);
                        }

                        if (yPos > initY) {
                            posArr.push(initY, yPos);
                        }
                        else {
                            posArr.push(yPos, initY);
                        }

                        this.selectArea = posArr;

                        if (this.dynamicList) {
                            this.selectRenderedCells(posArr);

                            delay('album_timeline:drag_select', () => {
                                this.selectNonRenderedCells(posArr);
                            }, 50);
                        }
                    },
                    onDragEnd: (wasDragging, yCorrection, rect, { target }) => {
                        if (!wasDragging
                            && this.selCount
                            && (target === this.el || target.classList.contains('MegaDynamicListItem'))) {
                            this.clearSiblingSelections();
                            this.selectArea = null;
                            this.lastNavNode = null;
                        }

                        this.selectStartNode = null;
                        this.shiftSelectedIndexes = [];
                    },
                    onScrollUp: () => {
                        if (!this.limitReached) {
                            this.dynamicList.scrollToYPosition(this.dynamicList.getScrollTop() - 20);
                        }
                    },
                    onScrollDown: () => {
                        if (!this.limitReached) {
                            this.dynamicList.scrollToYPosition(this.dynamicList.getScrollTop() + 20);
                        }
                    },
                    getOffsetTop: () => this.dynamicList.getScrollTop()
                }
            );
        }

        resetLastNavNode(shiftKey) {
            if (!this.lastNavNode) {
                if (this.selectStartNode) {
                    this.lastNavNode = this.selectStartNode;
                    return;
                }

                const selections = Object.keys(this.selections);

                if (selections.length) {
                    this.lastNavNode = M.d[selections[selections.length - 1]];
                }
            }

            if (shiftKey && !this.selectStartNode) {
                this.selectStartNode = this.lastNavNode || this._nodes[0].list[0];
            }
        }

        attachKeyboardListener() {
            if (scope.disposeKeyboardEvents) {
                scope.disposeKeyboardEvents();
            }

            scope.disposeKeyboardEvents = MComponent.listen(document, 'keydown', (evt) => {
                if (evt.target !== document.body) {
                    return;
                }

                const { key, shiftKey } = evt;
                const isCtrl = scope.getCtrlKeyStatus(evt);

                let rowIndex = -1;
                let inRowIndex = -1;
                let skipSelfSelect = false;

                this.resetLastNavNode(shiftKey);

                if (this.lastNavNode) {
                    rowIndex = this.rowIndexCache[this.lastNavNode.h];

                    inRowIndex = this._nodes[this.rowIndexCache[this.lastNavNode.h]].list
                        .findIndex(({ h }) => h === this.lastNavNode.h);
                }
                else {
                    rowIndex++;
                }

                const events = {
                    ArrowLeft: () => {
                        inRowIndex--;

                        if (inRowIndex < 0) {
                            rowIndex--;
                            inRowIndex = AlbumTimeline.zoomSteps[this.zoomStep] - 1;
                        }

                        if (rowIndex < 0 && !shiftKey && !isCtrl) {
                            rowIndex = this._nodes.length - 1;
                        }

                        if (this._nodes[rowIndex] && inRowIndex >= this._nodes[rowIndex].list.length) {
                            inRowIndex = this._nodes[rowIndex].list.length - 1;
                        }
                    },
                    ArrowRight: () => {
                        inRowIndex++;

                        if (inRowIndex >= this._nodes[rowIndex].list.length) {
                            rowIndex++;
                            inRowIndex = 0;
                        }

                        if (rowIndex >= this._nodes.length && !shiftKey && !isCtrl) {
                            rowIndex = 0;
                        }
                    },
                    ArrowUp: () => {
                        if (this.lastNavNode) {
                            rowIndex--;
                        }
                        else {
                            rowIndex = 0;
                            inRowIndex = 0;
                        }

                        if (rowIndex < 0 && !shiftKey && !isCtrl) {
                            rowIndex = this._nodes.length - 1;
                        }

                        if (!this._nodes[rowIndex]) {
                            return true;
                        }

                        const perRow = this._nodes[rowIndex].list.length;

                        if (inRowIndex >= perRow) {
                            inRowIndex = perRow - 1;
                        }

                        if (this.selectionLimit > 1 && !this.limitReached) {
                            const overLimit = this.selCount + perRow - this.selectionLimit;

                            if (overLimit > 0) {
                                inRowIndex += overLimit;

                                if (inRowIndex >= perRow) {
                                    rowIndex++;
                                    inRowIndex = perRow - inRowIndex;
                                }
                            }
                        }
                    },
                    ArrowDown: () => {
                        if (this.lastNavNode) {
                            rowIndex++;
                        }
                        else {
                            rowIndex = 0;
                            inRowIndex = 0;
                        }

                        if (rowIndex >= this._nodes.length && !shiftKey && !isCtrl) {
                            rowIndex = 0;
                        }

                        if (!this._nodes[rowIndex]) {
                            return true;
                        }

                        const perRow = this._nodes[rowIndex].list.length;

                        if (this._nodes[rowIndex] && inRowIndex >= perRow) {
                            inRowIndex = perRow - 1;
                        }

                        if (this.selectionLimit > 1 && !this.limitReached) {
                            const overLimit = this.selCount + perRow - this.selectionLimit;

                            if (overLimit > 0) {
                                inRowIndex -= overLimit;
                                if (inRowIndex < 0) {
                                    rowIndex--;
                                    inRowIndex = perRow + inRowIndex;
                                }
                            }
                        }
                    },
                    a: () => {
                        if (this.selectionLimit === 1) {
                            return true;
                        }

                        for (let i = 0; i < this._nodes.length; i++) {
                            for (let j = 0; j < this._nodes[i].list.length; j++) {
                                this.selectNode(this._nodes[i].list[j]);
                            }
                        }

                        this.lastNavNode = null;
                        skipSelfSelect = true;
                    },
                    Escape: () => {
                        if ($.dialog) {
                            if ($.dialog === 'm-dialog') {
                                scope.disposeKeyboardEvents();
                                scope.disposeKeyboardEvents = null;
                            }

                            evt.preventDefault();
                            evt.stopPropagation();
                            closeDialog();
                        }

                        return true;
                    },
                    Enter: () => {
                        evt.preventDefault();
                        evt.stopPropagation();

                        if ($.dialog) {
                            scope.disposeKeyboardEvents();
                            scope.disposeKeyboardEvents = null;
                            return true;
                        }

                        if (!this.selCount) {
                            return true;
                        }

                        if (this.selCount === 1) {
                            scope.playSlideshow(scope.getAlbumIdFromPath());
                        }
                        else {
                            scope.reportDownload();
                            M.addDownload(Object.keys(this.selections));
                        }

                        return true;
                    }
                };

                if (!events[key]) {
                    return;
                }

                if (isCtrl) {
                    evt.preventDefault();
                    evt.stopPropagation();
                }

                if (events[key]() === true
                    || rowIndex < 0
                    || rowIndex >= this._nodes.length
                    || !this._nodes[rowIndex]
                    || !this._nodes[rowIndex].list[inRowIndex]
                ) {
                    return true;
                }

                this.lastNavNode = this._nodes[rowIndex].list[inRowIndex];

                if (skipSelfSelect || !this.cellCache[this.lastNavNode.h]) {
                    return;
                }

                const performSelection = () => {
                    const { el } = this.cellCache[this.lastNavNode.h];

                    if (shiftKey) {
                        this.selectElementsRange(this.selectStartNode, this.lastNavNode);
                    }
                    else if (!isCtrl || !el.mComponent.isSelected) {
                        this.selectNode(this.lastNavNode);
                    }

                    this.scrollToSelectedRow(rowIndex);

                    if (!shiftKey && !isCtrl) {
                        this.clearSiblingSelections(this.lastNavNode.h);
                    }
                };

                performSelection();
            });
        }

        scrollToSelectedRow(rowIndex) {
            const newOffsetTop = this.dynamicList._offsets[rowIndex];
            const scrollTop = this.dynamicList.getScrollTop();

            if (newOffsetTop < scrollTop) {
                this.dynamicList.scrollToYPosition(newOffsetTop);
            }
            else {
                const bottomOverflow = newOffsetTop
                    + this.getRowHeight(rowIndex)
                    + scope.cellMargin
                    - (scrollTop + this.el.clientHeight);

                if (bottomOverflow > 0) {
                    this.dynamicList.scrollToYPosition(scrollTop + bottomOverflow);
                }
            }
        }

        getCellMonthCheck(cell) {
            let titleEl = cell.el.parentNode.parentNode;

            while (titleEl && !titleEl.classList.contains('has-month-label')) {
                titleEl = titleEl.previousElementSibling;
            }

            return titleEl && titleEl.querySelector('.checkdiv');
        }

        updateGroupSelect(cell) {
            const checkbox = this.getCellMonthCheck(cell);

            if (!checkbox) {
                return;
            }

            const rowIndex = checkbox.parentNode.dataset.row;

            delay(`album_timeline.check-select-${rowIndex}`, () => {
                const nodes = this.getMonthNodes(rowIndex);
                let all = true;
                let some = false;
                const selSet = new Set(Object.keys(this.selections));
                let i = nodes.length;

                while (--i >= 0) {
                    if (selSet.has(nodes[i])) {
                        some = true;
                    }
                    else {
                        all = false;
                    }

                    // All conditions met
                    if (some && !all) {
                        break;
                    }
                }

                checkbox.parentNode.mComponent.checked = all || some;

                if (all || !some) {
                    checkbox.classList.remove('checkboxMinimize');
                }
                else {
                    checkbox.classList.add('checkboxMinimize');
                }
            });
        }

        updateGroupDeselect(cell) {
            const checkbox = this.getCellMonthCheck(cell);

            if (!checkbox) {
                return;
            }

            const rowIndex = checkbox.parentNode.dataset.row;

            delay(`album_timeline.check-deselect-${rowIndex}`, () => {
                const sel = Object.keys(this.selections);
                let some = false;

                if (sel.length) {
                    const selSet = new Set(sel);
                    const monthNodes = this.getMonthNodes(rowIndex);

                    for (let i = 0; i < monthNodes.length; i++) {
                        if (selSet.has(monthNodes[i])) {
                            some = true;
                            break;
                        }
                    }
                }

                if (some) {
                    checkbox.classList.add('checkboxMinimize');
                }
                else {
                    checkbox.parentNode.mComponent.checked = false;
                    checkbox.classList.remove('checkboxMinimize');
                }
            });
        }

        /**
         * @param {Meganode} node Node to select
         * @param {boolean} [ignoreContainerCheck] Skiping the container check
         * @returns {void}
         */
        selectNode(node, ignoreContainerCheck = false) {
            if (this.limitReached) {
                if (!this.limitTip) {
                    this.addCountLimitTip();
                }

                return;
            }

            if (!this.selections[node.h]) {
                this.selections[node.h] = true;

                if (this.onSelectToggle) {
                    this.onSelectToggle(node);
                }

                const cell = this.cellCache[node.h];

                if (cell) {
                    cell.isSelected = true;

                    if (!ignoreContainerCheck && cell.el.isConnected) {
                        this.updateGroupSelect(cell);
                    }
                }

                this._selCount++;

                if (
                    this.selectionLimit > 1
                    && this.selCount >= this.selectionLimit
                ) {
                    this.addCountLimitTip();
                    this.limitReached = true;
                }

                this.adjustHeader();
            }
        }

        /**
         * @param {Meganode} node Node to deselect
         * @param {boolean} [ignoreContainerCheck] Skiping the container check
         * @returns {void}
         */
        deselectNode(node, ignoreContainerCheck = false) {
            if (this.selections[node.h]) {
                delete this.selections[node.h];

                if (this.onSelectToggle) {
                    this.onSelectToggle(node);
                }

                const cell = this.cellCache[node.h];

                if (cell) {
                    cell.isSelected = false;

                    if (!ignoreContainerCheck && cell.el.isConnected) {
                        this.updateGroupDeselect(cell);
                    }
                }

                this.adjustToBottomBar();

                this._selCount--;

                if (
                    this.limitReached
                    && this.selCount < this.selectionLimit
                ) {
                    this.removeCountLimitTip();
                    this.limitReached = false;
                }

                this.adjustHeader();
            }
        }

        addCountLimitTip() {
            if (this.limitTip) {
                return;
            }

            this.limitTip = document.createElement('div');
            this.limitTip.className = 'absolute bottom-0 right-0 w-full tooltip-popin timeline-tooltip';

            const icon = document.createElement('i');
            const message = document.createElement('span');
            const button = document.createElement('button');
            icon.className = 'sprite-fm-uni icon-hazard mr-4 icon-size-6';
            message.className = 'flex-1';
            message.textContent = mega.icu.format(l.album_items_limit, scope.maxSelectionsCount);
            button.textContent = l[81];

            const flex = document.createElement('div');
            flex.className = 'w-full flex flex-row items-center bg-surface-main rounded-2xl p-4';
            flex.appendChild(icon);
            flex.appendChild(message);
            flex.appendChild(button);
            this.limitTip.appendChild(flex);

            this.attachEvent(
                'click.hideSelectionLimit',
                () => {
                    this.removeCountLimitTip();
                },
                null,
                button
            );

            this.el.parentNode.appendChild(this.limitTip);
        }

        removeCountLimitTip() {
            if (this.limitTip) {
                this.disposeEvent('click.hideSelectionLimit');
                this.el.parentNode.removeChild(this.limitTip);
                delete this.limitTip;
            }
        }

        onResize() {
            if (this._winWidth === window.innerWidth && this._winHeight === window.innerHeight || !this.dynamicList) {
                return;
            }

            this.setCellSize();
            this._winWidth = window.innerWidth;
            this._winHeight = window.innerHeight;

            const keys = Object.keys(this.dynamicList._currentlyRendered);

            for (let i = 0; i < keys.length; i++) {
                this.dynamicList.itemChanged(keys[i]);
            }
        }

        setCellSize() {
            const gap = 8;

            this.cellSize = (this.el.offsetWidth
                - gap * AlbumTimeline.zoomSteps[this.zoomStep] // Cell margins
                - this.sidePadding * 2) // Horizontal padding
                / AlbumTimeline.zoomSteps[this.zoomStep]; // Columns
        }

        /**
         * Preparing and caching the cell result for the future use
         * @param {MegaNode} node Node to use for building the cell
         * @returns {AlbumTimelineCell}
         */
        getCachedCell(node) {
            if (this.cellCache[node.h]) {
                this.cellCache[node.h].isSensitive = !!mega.sensitives.isSensitive(node);
            }
            else {
                this.cellCache[node.h] = new AlbumTimelineCell({
                    node,
                    clickFn: this.onNodeClick,
                    dbclickFn: this.onNodeDbClick,
                    useMenu: this.interactiveCells
                });
            }

            return this.cellCache[node.h];
        }

        getMonthNodes(rowIndex) {
            if (this._nodes.length <= rowIndex) {
                return [];
            }

            let { monthLabel } = this._nodes[rowIndex];

            while (!monthLabel) {
                rowIndex--;
                monthLabel = this._nodes[rowIndex].monthLabel;
            }

            const handles = [];

            for (let i = rowIndex; i < this._nodes.length; i++) {
                if (i !== rowIndex && this._nodes[i].monthLabel) {
                    break;
                }

                handles.push(...this._nodes[i].list.map(({ h }) => h));
            }

            return handles;
        }

        applyMonthLabel(domNode, label, rowIndex) {
            const checkbox = new MCheckbox({
                id: `timeline-check-${rowIndex}`,
                name: `timeline_check_${rowIndex}`,
                passive: true
            });

            const monthNodes = this.getMonthNodes(rowIndex);
            const sel = Object.keys(this.selections);
            const selSet = new Set(sel);
            let all = sel.length >= monthNodes.length; // Presuming, based on length
            let some = false;

            for (let i = 0; i < monthNodes.length; i++) {
                if (selSet.has(monthNodes[i])) {
                    some = true;
                }
                else if (all) {
                    all = false;
                }

                if (some && !all) {
                    break;
                }
            }

            if (all) {
                checkbox.checked = true;
            }
            else if (some) {
                checkbox.checked = true;
                checkbox.el.firstChild.classList.add('checkboxMinimize');
            }

            checkbox.el.dataset.row = rowIndex;
            checkbox.onChange = (newVal) => {
                checkbox.checked = newVal;

                const nodes = this.getMonthNodes(rowIndex);

                if (newVal) {
                    for (let i = 0; i < nodes.length; i++) {
                        this.selectNode(M.d[nodes[i]], true);
                    }
                }
                else {
                    for (let i = 0; i < nodes.length; i++) {
                        this.deselectNode(M.d[nodes[i]], true);
                    }
                }

                checkbox.el.querySelector('.checkdiv').classList.remove('checkboxMinimize');
            };

            const dateTitle = document.createElement('div');
            dateTitle.classList.add(
                'timeline-date-title',
                'px-2',
                'py-3',
                'flex',
                'flex-row',
                'gap-2',
                'items-center'
            );

            const dateLabel = document.createElement('div');
            dateLabel.classList.add('font-bold', 'text-color-high');
            dateLabel.textContent = label;

            const countLabel = document.createElement('div');
            countLabel.className = 'text-color-medium font-body-2';
            countLabel.textContent = mega.icu.format(l.items_count, monthNodes.length);

            dateTitle.appendChild(checkbox.el);
            dateTitle.appendChild(dateLabel);
            dateTitle.appendChild(countLabel);
            domNode.appendChild(dateTitle);
        }

        removeMonthLabel(domNode) {
            const dateTitle = domNode.querySelector('.timeline-date-title');

            if (dateTitle) {
                domNode.removeChild(dateTitle);
            }
        }

        renderRow(rowKey) {
            const div = document.createElement('div');
            const row = document.createElement('div');
            row.className = 'flex flex-row';

            const toFetchAttributes = [];

            if (this._nodes[rowKey]) {
                const sizePx = `${this.cellSize}px`;
                const { list, monthLabel } = this._nodes[rowKey];

                if (this.showMonthLabel && monthLabel) {
                    this.applyMonthLabel(div, monthLabel, rowKey);
                    div.classList.add('has-month-label');
                }
                else {
                    this.removeMonthLabel(div);
                    div.classList.remove('has-month-label');
                }

                for (let i = 0; i < list.length; i++) {
                    const tCell = this.getCachedCell(list[i]);

                    tCell.el.style.width = sizePx;
                    tCell.el.style.height = sizePx;

                    scope.setShimmering(tCell.el);

                    if (this.selections[list[i].h]) {
                        tCell.isSelected = true;
                    }

                    tCell.isActive = !this.limitReached || tCell.isSelected;

                    row.appendChild(tCell.el);
                    fillAlbumTimelineCell(tCell.el);

                    tCell.el.ref.el = tCell.el;
                    toFetchAttributes.push(tCell.el.ref);
                }
            }

            if (toFetchAttributes.length) {
                delay(`album_timeline:render_row${rowKey}`, () => MegaGallery.addThumbnails(toFetchAttributes));
            }

            div.appendChild(row);

            return div;
        }

        /**
         * Selecting all nodes in between
         * @param {MegaNode} nodeA First node in the range
         * @param {MegaNode} nodeB Last node in the range
         * @param {Number} direction Selecting as 1 (from left to right) or -1 (from right to left)
         * @returns {void}
         */
        selectElementsRange(nodeA, nodeB) {
            const nodes = this._nodes.map(({ list }) => list).flat();
            let indexA = false;
            let indexB = false;
            const newIndexes = [];

            for (let i = 0; i < nodes.length; i++) {
                const { h } = nodes[i];

                if (h === nodeA.h) {
                    indexA = i;

                    if (nodeA.h === nodeB.h) {
                        indexB = i;
                    }
                }
                else if (h === nodeB.h) {
                    indexB = i;
                }

                if (indexA !== false && indexB !== false) {
                    break;
                }
            }

            if (indexA > indexB) {
                indexA += indexB;
                indexB = indexA - indexB;
                indexA -= indexB;
            }

            for (let i = indexA; i <= indexB; i++) {
                this.selectNode(nodes[i]);
                newIndexes.push(i);
            }

            for (let i = 0; i < this.shiftSelectedIndexes.length; i++) {
                if (!newIndexes.includes(this.shiftSelectedIndexes[i])) {
                    this.deselectNode(nodes[this.shiftSelectedIndexes[i]]);
                }
            }

            this.shiftSelectedIndexes = newIndexes;
        }

        adjustHeader() {
            delay('album_timeline:render_header', () => {
                if (albums.grid) {
                    albums.grid.header.update(scope.getAlbumIdFromPath(), Object.keys(this.selections));
                }
            }, 100);
        }

        adjustToBottomBar() {
            delay(
                'album_timeline:adjusting_to_bottom_bar',
                () => {
                    if (this.interactiveCells) {
                        this.el.style.minHeight = (this.selCount) ? '280px' : null;
                        this.resizeDynamicList();
                        Ps.update(this.el);
                    }
                },
                50
            );
        }

        resizeDynamicList() {
            if (this.dynamicList) {
                const prevScrollTop = this.dynamicList.getScrollTop();

                this.dynamicList.resized();
                this.dynamicList.scrollToYPosition(prevScrollTop);
            }
        }

        debouncedResize() {
            delay(
                'album_timeline:resize',
                () => {
                    this.resizeDynamicList();
                },
                100
            );
        }

        setZoomControls() {
            if (this.zoomControls) {
                return;
            }

            this.zoomControls = document.createElement('div');
            this.zoomControls.className = 'gallery-view-zoom-control';

            const buttons = [
                {
                    tooltip: l[24927],
                    classes: 'zoom-out',
                    icon: 'icon-minimise',
                    clickFn: () => {
                        this.zoomStep--;
                    },
                    checkIfDisabled: () => this.zoomStep <= 0
                },
                {
                    tooltip: l[24928],
                    classes: 'zoom-in',
                    icon: 'icon-add',
                    clickFn: () => {
                        this.zoomStep++;
                    },
                    checkIfDisabled: () => this.zoomStep >= AlbumTimeline.zoomSteps.length - 1
                }
            ];

            for (let i = 0; i < buttons.length; i++) {
                const { icon, clickFn, tooltip, classes, checkIfDisabled } = buttons[i];

                const btn = document.createElement('button');
                btn.className = `btn-icon simpletip ${classes}`;
                btn.dataset.simpletip = tooltip;
                const iconEl = document.createElement('i');
                iconEl.className = `sprite-fm-mono ${icon}`;
                btn.appendChild(iconEl);
                btn.onclick = () => {
                    clickFn();

                    if (checkIfDisabled()) {
                        btn.disabled = true;
                        btn.classList.add('disabled');
                    }

                    const sibling = btn.nextElementSibling || btn.previousElementSibling;

                    if (sibling && sibling.disabled) {
                        sibling.disabled = false;
                        sibling.classList.remove('disabled');
                    }
                };

                this.zoomControls.appendChild(btn);

                if ((!i && !this.zoomStep)
                    || (i === buttons.length - 1 && this.zoomStep === AlbumTimeline.zoomSteps.length - 1)) {
                    btn.disabled = true;
                    btn.classList.add('disabled');
                }
            }

            this.el.parentNode.prepend(this.zoomControls);
        }

        updateCell(node) {
            const cell = this.cellCache[node.h];

            if (!cell) {
                return;
            }

            cell.isSensitive = !!mega.sensitives.isSensitive(node);
        }

        buildElement() {
            this.el = document.createElement('div');
        }

        clear() {
            this.selections = {};

            if (this.dynamicList) {
                this.dynamicList.destroy();
                this.dynamicList = null;
            }

            if (this.zoomControls) {
                if (this.el.parentNode) {
                    this.el.parentNode.removeChild(this.zoomControls);
                }

                this.zoomControls = null;
            }

            if (this.dragSelect) {
                this.dragSelect.dispose();
            }

            if (scope.disposeKeyboardEvents) {
                scope.disposeKeyboardEvents();
                scope.disposeKeyboardEvents = null;
            }

            if (this.el && this.el.parentNode) {
                this.el.parentNode.removeChild(this.el);
            }
        }
    }

    AlbumTimeline.zoomSteps = [15, 10, 5, 3];
    return AlbumTimeline;
});

/**
 * This file handles the Notification Banner, which appears on the user's
 * Dashboard, CD, and Photos pages below the top navigation menu. One banner
 * will be shown at a time (the oldest first, if multiple notifications exist).
 * Once a user has closed the banner or clicked a CTA button, it will be marked
 * as actioned on the API server, and another banner will be shown if possible.
 */
var notificationBanner = {

    /** The id number of the last banner that the user has actioned */
    lastActionedBannerId: 0,

    /** The current notification being shown to the user */
    currentNotification: null,

    /** Whether the banner system has been inited or not */
    bannerInited: false,

    /** Whether the event for dismissing the banner has been sent or not */
    sendDismissedEvent: false,

    /**
     * Check if there are any banners that can be shown to the user, and set the last actioned
     * banner ID variable
     * @returns {void}
     */
    async init() {
        'use strict';

        // Get the last actioned banner ID user attribute
        this.lastActionedBannerId
            = parseInt(await Promise.resolve(mega.attr.get(u_handle, 'lbannr', -2, true)).catch(nop)) | 0;

        // Show the banner
        this.configureAndShowBanner();

        this.bannerInited = true;
    },

    /**
     * Wrapper function to configure the banner details and show it
     * @returns {Boolean} whether a banner can be shown or not
     */
    configureAndShowBanner() {
        'use strict';

        // Iterate through list of notifications to find earliest banner to show
        for (const key in notify.dynamicNotifs) {
            if (notify.dynamicNotifs[key]) {
                const notification = notify.dynamicNotifs[key];
                const notifIsActive = notification.e - unixtime() > 0;

                if (this.lastActionedBannerId < notification.id && notification.sb && notifIsActive) {
                    this.currentNotification = notification;

                    if (this.prefillBannerDetails()) {
                        if (!this.bannerPcListener || !this.bannerMultiTabsListener) {
                            this.addBroadcastListeners();
                        }

                        this.showBanner(true);

                        // Add a handler to fix the layout if the window is resized
                        $(window).rebind('resize.notifBanner', () => {
                            this.updateFMContainerHeight(true);
                        });

                        return true;
                    }
                }
            }
        }

        this.updateFMContainerHeight(false);

        delete this.currentNotification;
        return false;
    },

    /**
     * Update the details of the banner
     * @returns {Boolean} whether banner integrity is ok or not
     */
    prefillBannerDetails() {
        'use strict';

        const title = this.currentNotification.t;
        const description = this.currentNotification.d;

        let primaryButtonLabel;
        if (this.currentNotification.cta1) {
            primaryButtonLabel = this.currentNotification.cta1.text;
        }

        let secondaryButtonLabel;
        if (this.currentNotification.cta2) {
            secondaryButtonLabel = this.currentNotification.cta2.text;
        }

        if (!this.$banner) {
            this.$banner = $('.notification-banner');
        }

        if (!title || !description || !this.$banner.length) {
            return false;
        }

        // Populate the details
        $('.title', this.$banner).text(title);
        $('.message', this.$banner).text(description);

        const $primaryButton = $('.cta-primary', this.$banner);
        const $secondaryButton = $('.cta-secondary', this.$banner);

        $primaryButton.toggleClass('hidden', !this.currentNotification.cta1.link);
        if (this.currentNotification.cta1.link) {
            $primaryButton
                .attr('data-continue-link', this.currentNotification.cta1.link)
                .text(primaryButtonLabel);
        }

        $secondaryButton.toggleClass('hidden', !this.currentNotification.cta2.link);
        if (this.currentNotification.cta2.link) {
            $secondaryButton
                .attr('data-continue-link', this.currentNotification.cta2.link)
                .text(secondaryButtonLabel);
        }

        // Add event handlers for the buttons
        $('button.cta-primary, button.cta-secondary', this.$banner).rebind('click.bannerCtaBtns', (e) => {
            const pageLink = $(e.currentTarget).attr('data-continue-link');

            if (pageLink) {
                // If a link exists, open it in a new tab
                window.open(pageLink, '_blank', 'noopener,noreferrer');
            }
            else {
                // Otherwise, mark the banner as actioned
                this.markBannerAsActioned();
            }
        });
        $('.close.js-close', this.$banner).rebind('click.bannerClose', () => {
            this.sendDismissedEvent = true;
            this.markBannerAsActioned();
        });

        const $displayIcon = $('.display-icon', this.$banner).addClass('hidden');

        const icon = this.currentNotification.icon;
        if (icon) {
            // Determine icon path
            const retina = window.devicePixelRatio > 1 ? '@2x' : '';
            const imagePath = `${staticpath}images/mega/psa/${icon + retina}.png`;
            let failed = false;

            $displayIcon
                .attr('src', imagePath)
                .rebind('error.bannerImage', function() {
                    // If it failed once it will likely keep failing, prevent infinite loop
                    if (failed) {
                        $(this).addClass('hidden');
                        return;
                    }

                    $(this).attr('src', `${notificationBanner.currentNotification.dsp + icon + retina}.png`);
                    failed = true;
                })
                .rebind('load.bannerImage', function() {
                    $(this).removeClass('hidden');
                });
        }

        return true;
    },

    /**
     * Function to mark a banner as actioned, and to notify any open tabs of this.
     * @returns {void}
     */
    markBannerAsActioned() {
        'use strict';

        // Notify any other tabs a banner has been closed
        mBroadcaster.crossTab.notify('closedBanner', this.currentNotification.id);

        // Store that the user has actioned this banner on the API side
        // (as ^!lbannr for a private, non encrypted, non historic attribute)
        mega.attr.set('lbannr', String(this.currentNotification.id), -2, true);

        this.updateBanner(true);
    },

    /**
     * Attempt to show the banner and toggle some classes if required
     * @param {Boolean} [sendBannerShownEvent] Whether to send an event when the banner is shown.
     * @returns {void}
     */
    showBanner(sendBannerShownEvent) {
        'use strict';

        const isValidBannerPage = !M.chat && M.currentdirid !== 'refer'
            && !String(M.currentdirid).includes('account');

        if (isValidBannerPage) {
            delay('update-banner-classes', () => {
                const onDashboardPage =  M.currentdirid === 'dashboard';

                this.$banner.removeClass('hidden')
                    .toggleClass('no-max-width', !onDashboardPage)
                    .toggleClass('extra-bottom-padding', $('.onboarding-control-panel').is(':visible'));

                // Move the banner in the DOM if:
                // (1) the user navigates to the dashboard page (banner must be fixed there), or
                // (2) it has been moved before (move it back to its original position)
                if (onDashboardPage) {
                    this.$banner.insertBefore($('.widgets.content-block', '.fm-right-block.dashboard'));
                }
                else {
                    this.$banner.insertBefore($('.onboarding-control-panel'));
                }

                this.updateFMContainerHeight(true);
            }, 30);

            if (sendBannerShownEvent) {
                eventlog(500239, this.currentNotification.id | 0);
            }
        }
    },

    /**
     * Resize the currently shown FM container to prevent the page contents being cut off at the bottom
     *
     * @param {Boolean} bannerShown if the banner is currently being shown
     * @returns {void}
     */
    updateFMContainerHeight(bannerShown) {
        'use strict';

        if (M.currentdirid === 'dashboard') {
            return;
        }

        let activeFMContainer = '.fm-right-files-block:not(.in-chat)';

        if (M.currentdirid === 'recents') {
            activeFMContainer = '.fm-recents.container';
        }
        else if (M.currentdirid === 'devices') {
            activeFMContainer = '.fm-right-block.full-size';
        }

        if (bannerShown) {
            if (M.currentdirid !== 'albums') {
                // If a gallery empty state is visible, add a scroller to it so the contents
                // can be seen
                const $emptySection = $('.fm-empty-section:not(.hidden)', $(activeFMContainer));

                if (M.currentCustomView &&
                        M.currentCustomView.type === 'gallery' &&
                        !$emptySection.hasClass('hidden')) {
                    Ps.initialize($emptySection[0]);
                }
            }
        }
        else {
            // Remove any custom height styles set
            $('.fm-right-files-block:not(.in-chat)').removeAttr('style');
            $('.fm-right-block.dashboard').removeAttr('style');
            $('.fm-recents.container').removeAttr('style');
            $('.fm-right-block.full-size').removeAttr('style');
            $('.albums-grid', '#albums-view').removeAttr('style');

            // Remove any scrollbars added
            const $emptySection = $('.fm-empty-section.ps');
            if ($emptySection) {
                Ps.destroy($emptySection[0]);
            }

            $(window).unbind('resize.notifBanner');
        }
    },

    /**
     * Add the broadcast listners for:
     * (1) showing/hiding the banner as appropriate when navigating between pages
     * (2) when multiple tabs are open and a banner is closed on one of them
     * @returns {void}
     */
    addBroadcastListeners() {
        'use strict';

        this.bannerPcListener = mBroadcaster.addListener('pagechange', () => {
            // Hide the notifications banner while the page change is finishing up.
            this.$banner.addClass('hidden');

            onIdle(() => this.showBanner(false));
        });

        this.bannerMultiTabsListener = mBroadcaster.addListener('crossTab:closedBanner', (key) => {
            if (this.currentNotification.id === key.data) {
                this.updateBanner(true);
            }
        });
    },

    /**
     * Function to attempt to show a new banner if possible.
     * @param {Boolean} [updateLastActioned] Whether to set the last actioned banner ID or not.
     * @returns {void}
     */
    updateBanner(updateLastActioned) {
        'use strict';

        if (updateLastActioned) {
            this.lastActionedBannerId = this.currentNotification.id;
        }
        this.$banner.addClass('hidden');

        if (this.sendDismissedEvent) {
            eventlog(500241, this.currentNotification.id | 0);
            this.sendDismissedEvent = false;
        }

        // If no more banners are available to be shown, remove the broadcast listeners and reset them
        if (!this.configureAndShowBanner()) {
            mBroadcaster.removeListener(this.bannerPcListener);
            mBroadcaster.removeListener(this.bannerMultiTabsListener);
            delete this.bannerPcListener;
            delete this.bannerMultiTabsListener;
        }
    }
};

class MegaHeader extends MegaMobileHeader {

    constructor(options) {

        options.avatarButtonType = MegaButton;

        super(options);

        /* Top block */

        const navNavigation = this.domNode.querySelector('.top-block .nav-navigation');
        const navActions = this.domNode.querySelector('.top-block .nav-actions');
        let wrapper;

        navNavigation.querySelector('.home').classList.add('.hidden');

        // Remove mobile kebab menu
        const kebab = navActions.querySelector('.menu');
        if (kebab) {
            kebab.remove();
        }

        if (!mega.lite.inLiteMode) {

            // Search - Current using old search bar
            this.searchInput = options.parentNode.querySelector('.searcher-wrapper');
            this.searchInput.classList.add('search');
            this.searchInput.classList.remove('hidden');
            navNavigation.prepend(this.searchInput);

            // Notification
            wrapper = mCreateElement(
                'div',
                {class: 'menu-wrapper notif-wrapper notification js-dropdown-notification'},
                navActions
            );
            navActions.prepend(wrapper);

            this.notifButton = new MegaButton({
                parentNode: wrapper,
                type: 'icon',
                componentClassname: 'text-icon alarm',
                icon: 'sprite-fm-mono icon-bell-regular-outline',
                iconSize: 24,
                simpletip: l[862]
            });

            this.notifMenu = options.parentNode.querySelector('.notification-popup');

            wrapper.append(this.notifMenu);

            this.notifButton.on('click.list', e => {
                if (this.notifButton.toggleClass('active')) {
                    this.showNotifMenu();
                }
                else {
                    this.closeNotifMenu(e);
                }

                return false;
            });

            this.notifButton.domNode.prepend(mCreateElement('span', {class: 'js-notification-num icon-badge hidden'}));
        }

        // Bento Menus
        wrapper = mCreateElement('div', {class: 'menu-wrapper bento-wrapper bento'}, navActions);
        navActions.prepend(wrapper);

        this.bentoButton = new MegaButton({
            parentNode: wrapper,
            type: 'icon',
            componentClassname: 'text-icon bento',
            icon: 'sprite-fm-mono icon-bento-menu',
            iconSize: 24,
            simpletip: l.bento_title
        });

        // Component possibly
        this.bentoMenu = mCreateElement('div', {class: 'bento-menu hidden'}, wrapper);
        this.bentoMenu.items = {
            drive: {
                componentClassname: 'drive',
                text: l.drive,
                href: '/fm',
                icon: 'sprite-fm-mono icon-cloud-thin-outline',
                iconSize: 24,
                activeCondition: () => mega.ui.topmenu.hasClass('drive'),
                eventLog: 500446
            },
            chat: {
                componentClassname: 'chat',
                text: l[7997],
                href: '/fm/chat',
                icon: 'sprite-fm-mono icon-message-chat-circle-thin',
                iconSize: 24,
                activeCondition: () => M.chat,
                eventLog: 500294
            },
            pwm: {
                componentClassname: 'pwm',
                text: l.passwords,
                href: '/fm/pwm',
                icon: 'sprite-fm-mono icon-lock-thin-outline',
                iconSize: 24,
                activeCondition: () => M.currentCustomView.type === 'pwm',
                eventLog: 500628
            },
            vpn: {
                componentClassname: 'vpn extlink',
                text: l.vpn,
                href: 'https://mega.io/vpn',
                target: '_blank',
                icon: 'sprite-fm-mono icon-zap-thin-outline',
                iconSize: 24,
                eventLog: 500629
            },
            business: {
                componentClassname: 'business',
                text: l[19530],
                href: '/fm/user-management',
                icon: 'sprite-fm-mono icon-building',
                iconSize: 24,
                activeCondition: () => M.currentdirid.startsWith('user-management'),
                eventLog: 500630
            }
        };

        for (const key in this.bentoMenu.items) {
            if (this.bentoMenu.items.hasOwnProperty(key)) {
                const item = this.bentoMenu.items[key];
                this.bentoMenu.items[key] = [
                    new MegaLink({
                        parentNode: this.bentoMenu,
                        type: 'normal',
                        ...item
                    }),
                    item.activeCondition
                ];
            }
        }

        this.bentoButton.on('click.list', () => {
            if (this.bentoButton.toggleClass('active')) {
                this.showBentoMenu();
            }
            else {
                this.closeBentoMenu();
            }
        });

        if (mega.lite.inLiteMode) {
            const backtomega = new MegaLink({
                parentNode: navActions,
                text: l.back_to_mega,
                type: "normal",
                componentClassname: "outline",
                prepend: true
            });

            backtomega.on('click.backtomega', () => {

                // Remove the local storage variable which triggers MEGA Lite mode to load
                delete localStorage.megaLiteMode;

                // Store a log for statistics (User decided to go back to regular MEGA - Back to MEGA button)
                // Then reload the account back into regular MEGA
                loadingDialog.show();
                Promise.resolve(eventlog(99897)).finally(() => location.reload());
            });
        }

        if (!u_type) {

            const loginBtn = navActions.componentSelector('.login-button');

            loginBtn.addClass('outline').removeClass('action-link').off('tap').rebind('click.auth', () => {
                if (u_type === 0) {
                    mLogout();
                }
                else {
                    var c = $('.dropdown.top-login-popup', pmlayout).attr('class');
                    if (c && c.includes('hidden')) {
                        if (page === 'register') {
                            delay('registerloginevlog', () => eventlog(99818));
                        }
                        tooltiplogin.init();
                        return false;
                    }

                    tooltiplogin.init(1);

                }
            });

            if (u_type === 0) {
                loginBtn.text = l.log_out;
            }

            const signupBtn = new MegaLink({
                parentNode: navActions,
                text: l[968],
                type: "normal",
                componentClassname: "create-account-button primary"
            });

            signupBtn.on('click.signup', () => {
                if (this.hasClass('business-reg')) {
                    loadSubPage('registerb');
                }
                else {
                    if (page === 'login') {
                        delay('loginregisterevlog', () => eventlog(99798));
                    }
                    loadSubPage('register');
                }
            });

            this.topLangButton = new MegaButton({
                parentNode: navActions,
                type: 'normal',
                componentClassname: 'text-icon top-language underline',
                icon: 'sprite-fm-mono icon-languages',
                iconSize: 24,
                prepend: true,
                text: getRemappedLangCode(lang).toUpperCase(),
                onClick: () => {
                    langDialog.show();
                }
            });

            // Help menu
            wrapper = mCreateElement('div', {class: 'menu-wrapper help-wrapper top-help'});
            navActions.prepend(wrapper);

            this.topHelpButton = new MegaButton({
                parentNode: wrapper,
                type: 'icon',
                componentClassname: 'text-icon top-help',
                icon: 'sprite-fm-mono icon-help-circle-thin-outline',
                iconSize: 24,
                prepend: true
            });

            this.topHelpMenu = mCreateElement('div', {class: 'top-help-menu hidden header-dropdown-menu'}, wrapper);

            const items = Object.create(null);

            items.help = new MegaLink({
                parentNode: this.topHelpMenu,
                type: 'fullwidth',
                componentClassname: 'helpcentre extlink',
                text: l[384],
                target: '_blank',
                href: 'https://help.mega.io/'
            });

            mCreateElement('div', {class: 'horizontal-divider'}, this.topHelpMenu);

            items.csp = new MegaButton({
                parentNode: this.topHelpMenu,
                type: 'fullwidth',
                componentClassname: 'cookie-settings',
                text: l[24644],
                onClick: () => {
                    if ('csp' in window) {
                        csp.trigger().dump('csp.trigger');
                    }
                }
            });

            items.cookie = new MegaLink({
                parentNode: this.topHelpMenu,
                type: 'fullwidth',
                componentClassname: 'cookie-policy extlink',
                text: l[24629],
                target: '_blank',
                href: `${getBaseUrl()}/cookie`
            });

            mCreateElement('div', {class: 'horizontal-divider'}, this.topHelpMenu);

            items.terms = new MegaLink({
                parentNode: this.topHelpMenu,
                type: 'fullwidth',
                componentClassname: 'terms-of-service extlink',
                text: l[385],
                target: '_blank',
                href: 'https://mega.io/terms'
            });

            items.privacy = new MegaLink({
                parentNode: this.topHelpMenu,
                type: 'fullwidth',
                componentClassname: 'privacy-policy extlink',
                text: l[386],
                target: '_blank',
                href: 'https://mega.io/privacy'
            });

            mCreateElement('div', {class: 'horizontal-divider'}, this.topHelpMenu);

            items.copyright = new MegaLink({
                parentNode: this.topHelpMenu,
                type: 'fullwidth',
                componentClassname: 'copyright extlink',
                text: l.ra_type_copyright,
                target: '_blank',
                href: 'https://mega.io/copyright'
            });

            this.topHelpMenu.items = items;

            // Lets kill tap and move to click events
            this.topHelpButton.rebind('click', e => {
                if (this.topHelpButton.toggleClass('active')) {
                    this.showTopHelpMenu();
                }
                else {
                    this.closeTopHelpMenu(e);
                }
            });
        }

        // Temporary account status items fetch from old header until we revamp this
        let oldPopups = document.getElementById('header-account-states-popups');

        if (oldPopups) {
            oldPopups = oldPopups.cloneNode(true);
            oldPopups.id = 'old-header-account-states-popups';
            const remove = oldPopups.querySelectorAll(
                '.js-back-to-mega-button, .js-dropdown-account, .js-more-menu, .js-dropdown-notification');

            for (let i = remove.length - 1; i >= 0; i--) {
                remove[i].parentNode.removeChild(remove[i]);
            }
            navActions.prepend(oldPopups);
        }

        this.loader = mCreateElement('i', {class: 'fmdb-loader sprite-fm-uni icon-loading icon24'});

        navActions.prepend(this.loader);

        /* Bottom block */

        this.domNode.querySelector('.bottom-block .nav-navigation').textContent = '';
        this.domNode.querySelector('.bottom-block .nav-actions').textContent = '';

        this.resetBottomBlock = nop;
    }

    handleMenu(type, close) {

        const actions = close ? [
            'removeClass',
            'add',
            _ => _(),
            'removeEventListener'
        ] : [
            'addClass',
            'remove',
            onIdle,
            'addEventListener'
        ];

        mega.ui.header[`${type}Button`][actions[0]]('active');
        mega.ui.header[`${type}Menu`].classList[actions[1]]('hidden');

        if (bodyel) {

            actions[2](() => {

                const fcType = type.replace(/^./, char => char.toUpperCase());

                fmholder[actions[3]]('mouseup', mega.ui.header[`close${fcType}Menu`], true);
                fmholder[actions[3]]('contextmenu', mega.ui.header[`close${fcType}Menu`], true);
            });
        }
    }

    closeNotifMenu(e) {

        if (!mega.ui.header.notifMenu || e && (e.target === mega.ui.header.notifMenu ||
            e.target.closest('.js-notification-popup') && !e.target.closest('button, a') ||
            e.currentTarget === fmholder && e.target.closest('button.alarm'))) {
            return;
        }

        mega.ui.header.notifButton.parentNode.classList.remove('show');

        mega.ui.header.handleMenu('notif', true);
        notify.markAllNotificationsAsSeen();
        notify.dynamicNotifCountdown.removeDynamicNotifCountdown();
        mega.ui.header.notifButton.icon = mega.ui.header.notifButton.icon.replace('-filled', '-outline');
    }

    showNotifMenu() {
        mega.ui.header.notifButton.parentNode.classList.add('show');
        notify.renderNotifications();
        mega.ui.header.handleMenu('notif');
        mega.ui.header.notifButton.icon = mega.ui.header.notifButton.icon.replace('-outline', '-filled');
        eventlog(500322);
    }

    closeAvatarMenu(e) {

        if (!mega.ui.header.avatarMenu || e && (e.target === mega.ui.header.avatarMenu ||
            e.target.closest('.avatar-menu') && !e.target.closest('button, a') ||
            e.target.closest('.sub-menu-wrap') || e.target.closest('.top-mega-version') ||
            e.currentTarget === fmholder && e.target.closest('button.avatar'))) {
            return;
        }

        if (mega.ui.header.setStatus) {
            mega.ui.header.setStatus.classList.add('hidden');
        }

        mega.ui.header.handleMenu('avatar', true);
    }

    showAvatarMenu() {

        if (M.chat) {
            mega.ui.header.setStatus.classList.remove('hidden');
        }
        else {
            mega.ui.header.setStatus.classList.add('hidden');
        }

        MegaStorageBlock.checkUpdate();

        mega.ui.header.handleMenu('avatar');

        eventlog(500323);
    }

    closeBentoMenu(e) {

        if (!mega.ui.header.bentoMenu || e && (e.target === mega.ui.header.bentoMenu ||
            e.currentTarget === fmholder && e.target.closest('button.bento'))) {
            return;
        }

        mega.ui.header.handleMenu('bento', true);
    }

    showBentoMenu() {

        Object.values(this.bentoMenu.items).forEach(item => {
            if (item[1] && item[1]()) {
                item[0].addClass('active');
            }
            else {
                item[0].removeClass('active');
            }
        });

        mega.ui.header.handleMenu('bento');

        eventlog(500646);
    }

    closeTopHelpMenu(e) {

        if (!mega.ui.header.topHelpMenu || e && (e.target === mega.ui.header.topHelpMenu ||
            e.currentTarget === fmholder && e.target.closest('button.top-help'))) {
            return;
        }

        mega.ui.header.handleMenu('topHelp', true);
    }

    showTopHelpMenu() {
        mega.ui.header.handleMenu('topHelp');
    }

    updateUserName(newName) {
        const elem = this.avatarMenu.querySelector('.avatar-menu-name');
        elem.textContent = newName;
        elem.dataset.simpletip = newName;

        if (elem.scrollWidth > elem.offsetWidth) {
            elem.classList.add('simpletip');
        }
        else {
            elem.classList.remove('simpletip');
        }

        mega.ui.menu.calcPosition();
    }

    updateEmail(newEmail) {
        const elem = this.avatarMenu.querySelector('.avatar-menu-email');
        elem.textContent = newEmail;
        elem.dataset.simpletip = newEmail;

        if (elem.scrollWidth > elem.offsetWidth) {
            elem.classList.add('simpletip');
        }
        else {
            elem.classList.remove('simpletip');
        }

        mega.ui.menu.calcPosition();
    }

    set headerOptions(types) {
        for (var key in types) {
            if (types.hasOwnProperty(key)) {
                var value = types[key];
                const elements = this.domNode.getElementsByClassName(key);

                for (i = elements.length; i--;) {

                    const element = elements[i];

                    if (typeof value === 'string') {
                        element.textContent = value;
                    }

                    element.classList[value ? 'remove' : 'add']('hidden');
                }
            }
        }
    }

    update() {

        this.headerOptions = MegaHeader.getType();
        mega.ui.topmenu.megaLink.text = MegaHeader.getHeading();

        if (u_type || window.is_eplusplus) {
            this.bentoMenu.items.chat[0].show();
        }
        else {
            this.bentoMenu.items.chat[0].hide();
        }

        if (u_attr && u_attr.b && u_attr.b.m && (u_attr.b.s === 1 || u_attr.b.s === 2) && u_privk) {
            this.bentoMenu.items.business[0].show();
        }
        else {
            this.bentoMenu.items.business[0].hide();
        }

        if (M.chat && this.activityStatus) {
            window.mega.ui.searchbar.refresh();
            this.activityStatus.classList.remove('hidden');
        }
        else if (this.activityStatus) {
            this.activityStatus.classList.add('hidden');
        }

        tooltiplogin.init(1);
    }

    renderLoggedIn(replace) {

        // logged in but ephemeral
        if (u_type === 0) {

            const navActions = this.domNode.querySelector('.top-block .nav-actions');
            const loginLink = new MegaLink({
                parentNode: navActions,
                text: l.log_in,
                type: "normal",
                componentClassname: "action-link login-button"
            });

            mBroadcaster.once('login2', () => {
                this.renderLoggedIn(loginLink);
            });

            return;
        }

        super.renderLoggedIn(replace);

        const registerBtn = this.domNode.componentSelector('.create-account-button');
        if (registerBtn) {
            registerBtn.destroy();
        }

        // Avatar Menu
        useravatar.loadAvatar(u_handle).finally(() => {

            const avatarMeta = generateAvatarMeta(u_handle);
            const shortNameEl = mCreateElement('span', {}, [document.createTextNode(avatarMeta.shortName)]);

            const avatar = mCreateElement('div', {class: `${u_handle} avatar-wrapper`}, [
                avatarMeta.avatarUrl ? mCreateElement('img', {src: avatarMeta.avatarUrl})
                    : mCreateElement('div', {class: `color${avatarMeta.color}`}, [shortNameEl])
            ]);

            // Avatar menu, this can be component later
            this.avatarMenu = mCreateElement('div', {class: 'avatar-menu hidden header-dropdown-menu'}, [
                mCreateElement('div', {class: 'avatar-menu-header'}, [
                    mCreateElement('div', {class: 'avatar-menu-profile'}, [avatar.cloneNode(true)]),
                    mCreateElement('div', {class: 'avatar-menu-details'}, [
                        mCreateElement('div', {class: 'avatar-menu-name', 'data-simpletip': u_attr.fullname},
                                       [document.createTextNode(u_attr.fullname)]),
                        mCreateElement('div', {class: 'avatar-menu-email', 'data-simpletip': u_attr.email},
                                       [document.createTextNode(u_attr.email)])
                    ])
                ])
            ], this.avatarButton.domNode.parentNode);

            this.avatarMenu.Ps = new PerfectScrollbar(this.avatarMenu);

            window.addEventListener('resize', SoonFc(90, this.avatarMenu.Ps.update));

            this.activityStatus = mCreateElement('div', {'class': 'activity-status-block js-activity-status hidden'}, [
                mCreateElement('div', {'class': 'loading-animation'}),
                mCreateElement('div', {'class': 'activity-status top offline'})
            ]);
            this.avatarButton.domNode.appendChild(this.activityStatus);

            // Lets kill tap and move to click events
            this.avatarButton.off('tap').rebind('click', e => {
                if (this.avatarButton.toggleClass('active')) {
                    this.showAvatarMenu();
                }
                else {
                    this.closeAvatarMenu(e);
                }
            });

            const _buildInteractable = item => {
                const interactable = item.href ? MegaLink : MegaButton;

                return new interactable({
                    parentNode: this.avatarMenu,
                    type: 'fullwidth',
                    ...item
                });
            };

            const detailBlock = this.avatarMenu.querySelector('.avatar-menu-details');

            _buildInteractable({
                parentNode: detailBlock,
                type: 'text',
                componentClassname: 'to-my-profile',
                text: l[16668],
                href: 'fm/dashboard',
                eventLog: 500445
            });

            this.storageBlock = new MegaStorageBlock({
                parentNode: this.avatarMenu
            });

            mCreateElement('div', {class: 'horizontal-divider'}, this.avatarMenu);

            _buildInteractable({
                componentClassname: 'download-recovery-key',
                text: l.recovery_key_title,
                onClick: () => {
                    M.showRecoveryKeyDialog(2);
                },
                eventLog: 500312
            });

            mCreateElement('div', {class: 'horizontal-divider'}, this.avatarMenu);

            const _createSubMenu = (options) => {

                const wrapper = mCreateElement('div', {class: 'sub-menu-wrap'}, this.avatarMenu);
                options.items[0].parentNode = wrapper;
                const btn = _buildInteractable(options.items[0]);

                const submenu = mCreateElement('div', {class: options.submenuClass}, wrapper);

                for (var i = 1; i < options.items.length; i++) {

                    const item = options.items[i];

                    if (item.type === 'divider') {
                        mCreateElement('div', {class: 'horizontal-divider'}, submenu);
                    }
                    else {
                        item.parentNode = submenu;
                        _buildInteractable(item);
                    }
                }

                wrapper.addEventListener('mouseover', () => {

                    $(submenu).addClass('active').position({
                        my: "right top",
                        at: "left top",
                        of: btn.domNode,
                        collision: "flipfit"
                    });
                });

                wrapper.addEventListener('mouseout', () => {
                    submenu.classList.remove('active');
                });

                return wrapper;
            };

            const setPresence = presence => {

                if (!megaChatIsReady && !megaChatIsDisabled) {

                    localStorage.megaChatPresence = presence;
                    localStorage.megaChatPresenceMtime = unixtime();
                    loadSubPage('fm/chat');
                }

                this.closeAvatarMenu();
            };

            this.setStatus = _createSubMenu({
                submenuClass: 'header-dropdown-menu sub-menu status',
                items: [
                    {
                        componentClassname: 'set-status',
                        text: l[24845],
                        rightIcon: 'sprite-fm-mono icon-chevron-right-thin-outline'
                    },
                    {
                        icon: 'activity-status online',
                        iconSize: 8,
                        componentClassname: 'online',
                        text: l[5923],
                        onClick: () => {
                            setPresence('chat');
                        },
                        dataset: {presence: 'online'}
                    },
                    {
                        icon: 'activity-status away',
                        iconSize: 8,
                        componentClassname: 'away',
                        text: l[5924],
                        onClick: () => {
                            setPresence('away');
                        },
                        dataset: {presence: 'away'}
                    },
                    {
                        icon: 'activity-status busy',
                        iconSize: 8,
                        componentClassname: 'busy',
                        text: l[5925],
                        subtext: 'You will not receive any chat notifications',
                        onClick: () => {
                            setPresence('dnd');
                        },
                        dataset: {presence: 'dnd'}
                    },
                    {
                        icon: 'activity-status offline',
                        iconSize: 8,
                        componentClassname: 'offline',
                        text: l[5926],
                        subtext: 'You will not appear online, but will have full access to all of MEGA.',
                        onClick: () => {
                            setPresence('offline');
                        },
                        dataset: {presence: 'offline'}
                    }
                ]
            });

            _buildInteractable({
                componentClassname: 'settings',
                text: l[823],
                href: 'fm/account',
                eventLog: 500325
            });

            _buildInteractable({
                componentClassname: 'download-desktop-app extlink',
                target: '_blank',
                text: l.install_desktop_app,
                href: 'https://mega.io/desktop',
                eventLog: 500327
            });

            _buildInteractable({
                componentClassname: 'download-pwm-ext extlink',
                target: '_blank',
                text: l.try_pass_ext_download,
                href: this.pwmExtensionUrl
            });

            _buildInteractable({
                componentClassname: 'reload-account',
                text: l[23433],
                onClick: () => {
                    M.reload();
                }
            });

            _buildInteractable({
                type: 'normal',
                componentClassname: 'logout secondary',
                text: l.log_out,
                onClick: () => {
                    mLogout();
                },
                eventLog: 500329
            });


            _buildInteractable({
                componentClassname: 'select-language small-btn',
                text: l[670],
                onClick: () => {
                    langDialog.show();
                }
            });

            this.support = _createSubMenu({
                submenuClass: 'sub-menu support',
                items: [
                    {
                        componentClassname: 'support small-btn',
                        text: l[383],
                        rightIcon: 'sprite-fm-mono icon-chevron-right-thin-outline'
                    },
                    {
                        componentClassname: 'feedback',
                        text: l.join_survey_share_opinion,
                        onClick: () => {
                            mega.config.set('rvonbrddl', 1);
                            window.open(
                                'https://survey.mega.co.nz/index.php?r=survey/index&sid=692176&lang=en',
                                '_blank',
                                'noopener,noreferrer'
                            );
                            eventlog(500328);
                        }
                    },
                    {
                        componentClassname: 'helpcentre extlink',
                        text: l[384],
                        target: '_blank',
                        href: 'https://help.mega.io/'
                    },
                    {
                        componentClassname: 'megaio extlink',
                        text: l.website_label,
                        target: '_blank',
                        href: 'https://mega.io/'
                    }
                ]
            });

            this.legal = _createSubMenu({
                submenuClass: 'sub-menu legal',
                items: [
                    {
                        componentClassname: 'legal small-btn',
                        text: l[518],
                        rightIcon: 'sprite-fm-mono icon-chevron-right-thin-outline'
                    },
                    {
                        componentClassname: 'cookie-settings',
                        text: l[24644],
                        onClick: () => {
                            if ('csp' in window) {
                                csp.trigger().dump('csp.trigger');
                            }
                        }
                    },
                    {
                        componentClassname: 'cookie-policy extlink',
                        text: l[24629],
                        target: '_blank',
                        href: `${getBaseUrl()}/cookie`
                    },
                    {
                        type: 'divider'
                    },
                    {
                        componentClassname: 'terms-of-service extlink',
                        text: l[385],
                        target: '_blank',
                        href: 'https://mega.io/terms'
                    },
                    {
                        componentClassname: 'privacy-policy extlink',
                        text: l[386],
                        target: '_blank',
                        href: 'https://mega.io/privacy'
                    },
                    {
                        type: 'divider'
                    },
                    {
                        componentClassname: 'copyright extlink',
                        text: l.ra_type_copyright,
                        target: '_blank',
                        href: 'https://mega.io/copyright'
                    }
                ]
            });

            const footer = mCreateElement('div', {class: 'avatar-menu-footer'}, this.avatarMenu);

            let versionClickCounter = 0;

            _buildInteractable({
                parentNode: footer,
                type: 'text',
                componentClassname: 'version top-mega-version',
                text: `V.${M.getSiteVersion()}`,
                onClick: () => {
                    if (++versionClickCounter >= 3) {
                        mega.developerSettings.show();
                    }
                    delay('top-version-click', () => {
                        versionClickCounter = 0;
                    }, 1000);
                }
            });
        });
    }

    static init(update) {
        const {topmenu, header} = mega.ui;

        topmenu.hide();

        if (update) {
            header.update();
        }
    }

    static types(index) {
        const type = [
            { // logged in default
                'home': false,
                'top-block': true,
                'search': true,
                'notification': !pfid && u_type,
                'bottom-block': false,
                'avatar': true,
                'bento': u_type || is_eplusplus,
                'heading': true,
                'top-help': !u_type,
                'top-language': !u_type,
                'download-desktop-app': M.currentCustomView.type !== 'pwm' && !window.useMegaSync,
                'download-pwm-ext': M.currentCustomView.type === 'pwm'
            },
            { // logged out
                'home': false,
                'top-block': true,
                'search': true,
                'notification': false,
                'bottom-block': false,
                'avatar': false,
                'bento': false,
                'heading': true,
                'top-help': true,
                'top-language': true,
                'download-desktop-app': false,
                'download-pwm-ext': false
            }
        ][index];

        if (pfcol || // Album link
            M.chat || // Chat or meetings
            M.currentCustomView.type === 'pwm' || // password manager
            M.currentdirid && (
                M.currentdirid.startsWith('account') || // settings
                M.currentdirid === 'dashboard' || // dashboard
                M.currentdirid.startsWith('user-management') // Business pages
            )
        ) {
            type.search = false;
        }

        return type;
    }

    static getPage() {
        if (is_fm()) {
            if (pfid) {
                return (pfcol) ? 'collectionlink' : 'folderlink';
            }

            if ([M.RootID, 's4', 'shares', 'out-shares', 'public-links', 'faves', M.RubbishID, 'recents',
                 'file-requests'].includes(M.currentrootid) ||
                M.isGalleryPage() || M.isAlbumsPage() ||
                M.currentrootid === M.InboxID || // Temporary title for backup
                M.currentdirid === 'devices' || M.currentdirid === 'transfers' || M.search) {
                return 'drive';
            }
            else if (M.currentCustomView.type === 'pwm') {
                return 'pwm';
            }
            else if (M.currentdirid === 'account') {
                return 'settings';
            }
        }
        return page;
    }

    static getType() {
        const iType = u_attr ? 0 : 1;

        return this.types(iType);
    }

    set topBlockBottomBorder(show) {

        const topBlock = this.domNode.querySelector('.top-block');

        if (topBlock) {
            topBlock.classList[show ? 'add' : 'remove']('border-bottom');
        }
    }

    get pwmExtensionUrl() {
        return ua.details.browser === 'Edgium' ? 'https://microsoftedge.microsoft.com/addons/detail/' +
            'mega-pass-secure-passwor/hjdopmdfeekbcakjbbienpbkdldkalfe' :
            ua.details.browser === 'Firefox' ? 'https://addons.mozilla.org/en-US/firefox/addon/mega-password-manager/' :
                'https://chromewebstore.google.com/detail/mega-pass/deelhmmhejpicaaelihagchjjafjapjc';
    }
}

(mega => {
    "use strict";

    lazy(mega.ui, 'header', () => new MegaHeader({
        parentNode: pmlayout,
        componentClassname: 'mega-header',
        prepend: true
    }));

})(window.mega);

lazy(MegaHeader, 'headings', () => {
    'use strict';

    // We do not need mobile ones
    delete MegaMobileHeader.headings;

    return Object.freeze({
        'drive': l.drive,
        'pwm': l.mega_pwm,
        'settings': l[823],
        'folderlink': l[808],
        'collectionlink': l.album_link
    });
});

class MegaTopMenu extends MegaMobileTopMenu {

    constructor(options) {

        super(options);

        this.megaLink.interactableType = 'normal';
        this.megaLink.icon = 'sprite-fm-uni icon-mega-logo';

        this.menuNode.Ps = new PerfectScrollbar(this.menuNode);
        mBroadcaster.addListener('pagechange', () => this.menuNode.Ps.update());
        this.on('click.topmenuClicked', () => {

            // Adding this classname if it is required to make CSS applies first so Ps can position scrollbar correctly
            this.menuNode.classList.remove('ps--active-x', 'ps--active-y');

            if (this.menuNode.scrollWidth > this.menuNode.offsetWidth) {
                this.menuNode.classList.add('ps--active-x');
            }
            if (this.menuNode.scrollHeight > this.menuNode.offsetHeight) {
                this.menuNode.classList.add('ps--active-y');
            }
            this.menuNode.Ps.update();
        });

        window.addEventListener('resize', SoonFc(90, this.menuNode.Ps.update));

        this.domNode.prepend(mCreateElement('div', {'class': 'left-pane-drag-handle'}));

        M.onFileManagerReady(() => {
            this.leftPaneResizable = $.leftPaneResizable = new FMResizablePane($(this.domNode), {
                'direction': 'e',
                'minWidth': mega.flags.ab_ads ? 260 : 200,
                'maxWidth': 400,
                'persistanceKey': 'leftPaneWidth',
                'handle': '.left-pane-drag-handle'
            });
        });

    }

    renderMenuItems() {

        this.ready = this.ready || 0;

        if (pfid && !(this.ready & 1) || !pfid && !(this.ready & 2)) {
            super.renderMenuItems();
        }
    }

    closeActiveOverlays() {

        if (mega.ui.pm && (mega.pm.pwmFeature || u_attr.b || u_attr.pf) && mega.ui.pm.overlay.visible) {
            mega.ui.passform.discard(mega.ui.passform.isFormChanged).then(res => {
                if (res) {
                    mega.ui.pm.overlay.hide();
                    mega.ui.passform.clear();
                }
            });
        }
    }

    // Override for desktop
    get menuItems() {

        const _openContext = ev => {
            M.contextMenuUI(ev.originalEvent, 1);
            return false;
        };

        if (pfid) {

            this.ready |= 1;

            return [{
                text: M.getNameByHandle(M.RootID),
                icon: 'sprite-fm-mime icon-folder-24',
                href: `/${pfcol ? 'collection' : 'folder'}/${pfid}`,
                hasTree: pfcol ? false : 'cloud-drive',
                treeWrapClass: 'js-public-tree-panel',
                name: 'root-folder',
                typeClassname: 'root-folder folder-link',
                onContextmenu: _openContext
            }];
        }

        this.ready |= 2;

        const loggedInCD = [
            // Cloud drive menus
            {
                text: l[164],
                icon: 'sprite-fm-mono icon-cloud-thin-outline',
                href: '/fm',
                hasTree: 'cloud-drive',
                treeWrapClass: 'js-myfile-tree-panel',
                name: 'cloud-drive',
                typeClassname: 'drive',
                onContextmenu: _openContext,
                eventLog: 500631
            },
            {
                text: l.shared_items,
                icon: 'sprite-fm-mono icon-folder-users-thin-outline',
                href: '/fm/shares',
                hasTree: 'shared-with-me', // hidden tree for copy dialog
                treeWrapClass: 'hidden-tree',
                name: 'shares',
                typeClassname: 'drive',
                eventLog: 500641
            },
            {
                type: 'spacer',
                typeClassname: 'drive'
            },
            {
                text: l[1346],
                icon: 'sprite-fm-mono icon-arrows-up-down-circle-thin-outline',
                href: '/fm/transfers',
                name: 'transfers',
                typeClassname: 'drive',
                eventLog: 500634
            },
            {
                text: l[167],
                icon: 'sprite-fm-mono icon-trash-thin-outline',
                href: '/fm/rubbish',
                name: 'rubbish-bin',
                typeClassname: 'drive',
                onContextmenu: _openContext,
                eventLog: 500635
            },

            // Password Manager menus
            {
                text: l.rewind_label_all_default,
                icon: 'sprite-pm-mono icon-square-regular-outline',
                href: '/fm/pwm',
                name: 'pwm',
                typeClassname: 'pwm'
            },
            {
                text: l[823],
                icon: 'sprite-mobile-fm-mono icon-settings-thin-outline',
                href: '/fm/pwm/account',
                typeClassname: 'pwm',
                name: 'pwm-settings',
                eventLog: 500573
            }
        ];

        if (!mega.lite.inLiteMode) {

            loggedInCD.splice(1, 0, {
                text: l.media,
                icon: 'sprite-fm-mono icon-image-01-thin-outline',
                href: '/fm/photos',
                name: 'media',
                typeClassname: 'drive',
                eventLog: 500447
            });

            loggedInCD.splice(3, 0, {
                text: l.device_centre,
                icon: 'sprite-fm-mono icon-devices-thin-outline',
                href: '/fm/devices',
                name: 'devices',
                typeClassname: 'drive',
                eventLog: 500448
            });

            loggedInCD.splice(5, 0, {
                text: l[20141],
                icon: 'sprite-fm-mono icon-clock-thin-outline',
                href: '/fm/recents',
                name: 'recents',
                typeClassname: 'drive',
                eventLog: 500632
            }, {
                text: l.gallery_favourites,
                icon: 'sprite-fm-mono icon-heart-thin-outline',
                href: '/fm/faves',
                name: 'faves',
                typeClassname: 'drive',
                eventLog: 500633
            });
        }

        if (u_attr && u_attr.s4) {

            // push below object to loggedInCD 2nd place
            loggedInCD.splice(1, 0, {
                text: l.obj_storage,
                icon: 'sprite-fm-mono icon-bucket-triangle-thin-outline',
                binding() {
                    M.require('s4').then(() => {
                        if (!(M.dyh && M.dyh('is-section', 'container') || s4.utils.getContainersList().length > 1)){
                            s4.ui.renderRoot();
                        }
                    });
                },
                hasTree: 's4',
                treeWrapClass: 'js-s4-tree-panel',
                name: 's4',
                typeClassname: 'drive',
                eventLog: 500636
            });
        }

        return loggedInCD;
    }

    toggleActive() {

        const active = this.domNode.componentSelector('.menu-item.active');

        if (active) {
            active.removeClass('active');
            active.icon = active.icon.replace('solid', 'outline');
        }

        const items = this.domNode.getElementsByClassName('menu-item');
        const _isMedia = () => M.isGalleryPage() && mega.gallery.sections[M.currentdirid] ||
            (M.isGalleryPage() || M.isAlbumsPage()) && mega.gallery.albums;
        const _isTreeItemOrSearch = () => M.currentrootid === M.RootID ||
            M.currentCustomView.type === 's4' || M.search;
        const _getSelected = () => {

            let selected;
            let type = 'drive';

            if (pfid) {
                type = 'folderlink';
                selected = M.currentdirid === M.RootID ? items['root-folder'] : true;
            }
            else if (M.currentdirid === M.RootID) {
                selected = items['cloud-drive'];
            }
            else if (M.currentdirid === 'devices' || M.currentrootid === M.InboxID) {
                selected = items.devices;
            }
            else if (['shares', 'out-shares', 'public-links', 'file-requests'].includes(M.currentrootid)) {
                selected = items.shares;
            }
            else if (M.currentdirid === 'recents') {
                selected = items.recents;
            }
            else if (M.currentrootid === M.RubbishID) {
                selected = items['rubbish-bin'];
            }
            else if (M.isDynPage(M.currentdirid)) {
                selected = items[M.currentdirid];
            }
            else if (_isMedia()) {
                selected = items.media;
            }
            else if (M.currentrootid === 's4' && M.currentCustomView.subType === 'container') {
                selected = items.s4;
            }
            else if (M.currentdirid === 'transfers') {
                selected = items.transfers;
            }
            else if (M.currentCustomView.type === 'pwm') {
                selected = M.currentCustomView.nodeID === 'account' ? items['pwm-settings'] : items.pwm;
                type = 'pwm';
            }
            // Tree view item selected or search result, so just return true to show menu.
            else if (_isTreeItemOrSearch()) {
                type = 'drive';
                selected = true;
            }

            return {selected, type};
        };

        const {selected, type} = _getSelected();

        if (!this.storageBlock) {
            this.storageBlock = new MegaStorageBlock({
                parentNode: this.domNode
            });
        }

        this.storageBlock[type === 'drive' ? 'show' : 'hide']();
        this.removeClass('drive', 'pwm', 'other', 'folderlink');
        this.activeItem = null;

        if (selected) {
            this.removeClass('hidden');
            if (selected !== true) {
                selected.classList.add('active');
                selected.component.icon = selected.component.icon.replace('outline', 'solid');
                this.activeItem = selected;
            }
            this.addClass(type);

            // Temporary solution for hide old navs
            const oldPanel = this.domNode.parentNode.querySelector('.js-fm-left-panel');
            if (oldPanel) {
                oldPanel.classList.add('hidden');
            }
        }
        else {
            this.addClass('hidden');

            // Temporary solution for hide old navs
            const oldPanel = this.domNode.parentNode.querySelector('.js-fm-left-panel');

            if (oldPanel) {
                oldPanel.classList[M.chat ? 'add' : 'remove']('hidden');
            }
        }
    }
}

(mega => {
    "use strict";

    lazy(mega.ui, 'topmenu', () => new MegaTopMenu({
        parentNode: pmlayout,
        componentClassname: 'mega-top-menu',
        prepend: true
    }));

})(window.mega);

class MegaStorageBlock extends MegaComponent {

    constructor(options) {
        super(options);

        this.domNode.classList.add('storage-block');

        const infoBlock = mCreateElement('div', {class: 'info'}, [
            mCreateElement('div', {class: 'loader menus-sprite loading'})
        ]);

        this.storageBlock = mCreateElement('section', {class: 'js-storage-usage storage-usage'}, [
            mCreateElement('div', {class: 'storage-usage-panel js-storage-usage-block'}, [
                mCreateElement('div', {class: 'title-block'}, [
                    mCreateElement('div', {class: 'plan'}),
                    mCreateElement('div', {class: 'text-and-tooltip'}, [
                        mCreateElement('div', {class: 'storage-txt'}),
                        mCreateElement('i', {class: 'icon sprite-fm-mono icon-info storage-limit-icon hidden'}),
                        mCreateElement('div', {class: 'lp-storage-limit-popup'}, [
                            document.createTextNode(l.storage_limit_tooltip)
                        ])
                    ])
                ]),
                mCreateElement('div', {class: 'storage-graph js-storagegraph hidden'}, [
                    mCreateElement('span')
                ]),
                infoBlock
            ]),
            mCreateElement('div', {class: 'js-lp-storage-information-popup lp-storage-information-popup hidden'})
        ], this.domNode);

        let eventid = 500477;

        if (this.parentNode === mega.ui.header.avatarMenu) {
            eventid = 500478;
        }

        // Upgrade button
        MegaTopMenu.renderUpgradeButton(infoBlock, eventid);

        M.onFileManagerReady(() => this.checkUpdate());
    }

    // TODO: need further update to make more fit on component
    async checkUpdate(data) {

        const _checkCondition = () => !u_type || !fminitialized || (!data && M.storageQuotaCache);

        if (_checkCondition()) {

            if (u_type === 0 && this.storageBlock) {
                this.storageBlock.classList.add('hidden');
            }

            return false;
        }

        this.storageBlock.classList.remove('hidden');

        this.showLoading();

        M.storageQuotaCache = data || await M.getStorageQuota();

        let storageHtml;
        const {percent, max, used, isAlmostFull, isFull} = M.storageQuotaCache;
        const space = bytesToSize(max, 0);
        const space_used = bytesToSize(used);

        this.storageBlock.classList.remove('over');
        this.storageBlock.classList.remove('warning');

        if (isFull) {
            this.storageBlock.classList.add('over');
        }
        else if (isAlmostFull) {
            this.storageBlock.classList.add('warning');
        }

        const isFlexPlan = () => u_attr.b || u_attr.pf;
        const isFlexPlanActive = () => u_attr.b && u_attr.b.m && u_attr.b.s === pro.ACCOUNT_STATUS_ENABLED
            || u_attr.pf && u_attr.pf.s === pro.ACCOUNT_STATUS_ENABLED;
        const $upgradeBtn = $('.info a.upgrade', this.storageBlock);

        // If Business or Pro Flexi always show the plan name (even if expired, which is when u_attr.p is undefined)
        if (isFlexPlan()) {
            this.storageBlock.querySelector('.plan').textContent = pro.getProPlanName(
                u_attr.b ? pro.ACCOUNT_LEVEL_BUSINESS : pro.ACCOUNT_LEVEL_PRO_FLEXI
            );

            // Show only space_used for Business and Pro Flexi accounts
            storageHtml = `<span class="lp-sq-used">${space_used}</span>`;
            if (isFlexPlanActive()) {
                $upgradeBtn.addClass('hidden');
            }
        }
        else {
            this.storageBlock.querySelector('.plan').textContent = pro.getProPlanName(u_attr.p || l[1150]);
            storageHtml = l[1607].replace('%1', `<span class="lp-sq-used">${space_used}</span>`)
                .replace('%2', `<span class="lp-sq-max">${space}</span>`);
            this.storageBlock.querySelector('.js-storagegraph').classList.remove('hidden');
            $('.js-storagegraph span', this.storageBlock).outerWidth(`${percent}%`);

            // Check if user (not a Business or Pro Flexi one) is in the fmpup (FM / Photos upgrade point)
            // variant group and change the upgrade point UI if so
            if (!data && M.isInExperiment('fmpup')) {
                const $storageLimitIcon = $('.storage-limit-icon', this.storageBlock);

                const _sendEvent = (eventId) => {
                    // Send eventlog and a message with the tab the user was on
                    // (Drive / Photos) when they clicked the buttons
                    const isCloudDrive = M.currentrootid === M.RootID;
                    const eventMessage = `${isCloudDrive ? 'Drive' : 'Photos'} tab selected`;

                    eventlog(eventId, eventMessage);
                };

                if (this.parentNode !== mega.ui.header.avatarMenu) {
                    $upgradeBtn.removeClass('hidden').rebind('click.sendEvent', () => {
                        _sendEvent(500282);
                    });
                }

                this.storageBlock.querySelector('.text-and-tooltip').classList.remove('hidden');

                if (isAlmostFull || isFull) {
                    $storageLimitIcon.removeClass('hidden').rebind('click.sendEvent', () => {
                        _sendEvent(500283);

                        const hcArticleURL = 'https://help.mega.io/plans-storage/space-storage/storage-exceeded';
                        window.open(hcArticleURL, '_blank', 'noopener noreferrer');
                    });
                }
            }
        }

        $('.storage-txt', this.storageBlock).safeHTML(storageHtml);

        this.hideLoading();

        if (!isFlexPlan() && (!u_attr.tq || !this.storageBlock.classList.contains('caption-running'))) {
            this.storageBlock.classList.add('caption-running');
            return this.createLeftStorageBlockCaption(this.storageBlock, space);
        }
    }

    showLoading() {

        this.loaderSpinner = this.loaderSpinner || this.storageBlock.querySelector('.loader');

        // minimize DOM ops when not needed by only triggering the loader if really needed
        if (this.loaderSpinner) {
            this.loaderSpinner.classList.add('loading');
        }
    }

    hideLoading() {

        this.loaderSpinner = this.loaderSpinner || this.storageBlock.querySelector('.loader');

        if (this.loaderSpinner) {
            this.loaderSpinner.remove();
        }
    }

    async createLeftStorageBlockCaption(container, storageQuota) {

        let checked = false;
        const $storageBlock = $(container);
        const $popup = $('.js-lp-storage-information-popup', $storageBlock.parent()).removeClass('hidden');
        const $storageLimitIcon = $('.storage-limit-icon', $storageBlock);
        const $storageLimitPopup = $('.lp-storage-limit-popup', $storageBlock);

        $storageBlock.rebind('mouseenter.storage-usage', () => {
            if (!checked) {
                checked = true;

                Promise.resolve(!u_attr.p || u_attr.tq || M.getTransferQuota())
                    .then((res) => {
                        if (typeof res === 'object') {
                            // base transfer quota from getTransferQuota()
                            res = res.base;
                        }
                        if (typeof res === 'number') {
                            res = bytesToSize(res, 3, 4);
                        }

                        if (u_attr.p) {
                            u_attr.tq = res;
                            $popup.text(l.storage_usage_caption_pro.replace('%1', storageQuota)
                                .replace('%2', u_attr.tq));
                        }
                        else {
                            $popup.text(l.storage_usage_caption_free.replace('%1', storageQuota));
                        }
                    });
            }

            delay('storage-information-popup-mouseenter', () => {
                if (!$storageLimitIcon.is(':hover')) {
                    $popup.addClass('hovered');
                }
            }, 1e3);
        });

        $storageBlock.rebind('mouseleave.storage-usage', () => {
            delay.cancel('storage-information-popup-mouseenter');
            delay.cancel('storage-information-popup-mouseleave');
            $popup.removeClass('hovered');
            $storageLimitPopup.removeClass('hovered');
        });

        $storageLimitIcon.rebind('mouseenter.storage-limit', () => {
            delay('storage-limit-popup-mouseenter', () => {
                $storageLimitPopup.addClass('hovered');
                $popup.removeClass('hovered');
            }, 1e3);
        });

        $storageLimitIcon.rebind('mouseleave.storage-limit', () => {
            delay.cancel('storage-limit-popup-mouseenter');
            $storageLimitPopup.removeClass('hovered');
            delay('storage-information-popup-mouseleave', () => {
                if ($storageBlock.is(':hover')) {
                    $popup.addClass('hovered');
                }
            }, 1e3);
        });
    }

    static async checkUpdate() {

        await mega.ui.topmenu.storageBlock.checkUpdate();

        if (mega.ui.header.avatarMenu && !mega.ui.header.avatarMenu.classList.contains('hidden')) {
            mega.ui.header.storageBlock.checkUpdate(M.storageQuotaCache);
        }
    }
}
